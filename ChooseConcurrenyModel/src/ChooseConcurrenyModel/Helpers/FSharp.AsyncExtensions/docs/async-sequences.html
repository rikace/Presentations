<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" ><head>
  <link rel="stylesheet" href="C:\Tomas\Writing\Articles\Blog\style.css" />
  <script type="text/javascript" src="C:\Tomas\Writing\Articles\Blog\tips.js">  
  </script>
</head><body>
<div id="body" style="max-width:890px"><div id="body1"><div id="body2">
<div id="page"><div id="wholecontent"><div id="content">


<h1>Programming with F# asynchronous sequences</h1>

<img src="async-sequences/decor.png" class="rdecor" />

<p>In F#, we can represent asynchronous operations that do not block threads and eventually
  return a value of type <code>'T</code> using asynchronous workflows <code>Async&lt'T&gt;</code>.
  Asynchronous workflows can be easily constructed using the computation expression syntax
  <code>async { ... }</code> and there are also a few combi&#173;nators that express more advanced
  composition (such as parallel composition or fork-join parallelism).</p>

<p>Sometimes, we need to use asynchronous operations that return more than just one value.
  For example, when downloading data from the internet, we would like to create an 
  <em>asynchronous sequence</em> that returns the data in chunks as they become available.</p>

<p>One way to represent asynchronous operations that produce multiple values is to use 
  the <code>IObservable&lt;'T&gt;</code> type from .NET. This isn't always the best option 
  though. Observables implement <em>push-based</em> model, which means that chunks of data are
  generated as quickly as possible (until all chunks are emitted). What if we wanted to take 
  the chunks one-by-one after the previous chunk is processed?</p>

<p>In this article, I describe <em>asynchronous sequences</em>. An asynchronous sequence is a simple,
  yet very powerful concept based on asynchronous workflows. It follows the same core model: results 
  are generated on demand and asynchronously. Unlike asynchronous workflows, asynchronous sequences
  can be called (on demand) to generate multiple values until the end of the sequence is reached.</p>

<p style="font-style:italic">I first discussed asynchronous sequences with Don Syme, Dmitry Lomov and Brian McNamara in an
  email thread a long time ago. Thanks to Don for enthusiasm about the concept and for the 
  first implementation of some of the combinators!</p>

<h2>Introducing asynchronous sequences</h2>
<p>Asynchronous sequences that emit values of type <code>'T</code> are represented by a type 
  <code>AsyncSeq&lt;'T&gt;</code>. The type is surprisignly simple. It follows the same pattern
  as the definition of standard F# list or a <code>LazyList&lt;'T&gt;</code> type from F#
  PowerPack:</p>

<pre class="fssnip">
<span class="l">1: </span><span class="c">///</span><span class="c"> </span><span class="c">Asynchronous</span><span class="c"> </span><span class="c">computation</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">produces</span><span class="c"> </span><span class="c">either</span><span class="c"> </span><span class="c">end</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">a</span><span class="c"> </span><span class="c">sequence</span>
<span class="l">2: </span><span class="c">///</span><span class="c"> </span><span class="c">(Nil)</span><span class="c"> </span><span class="c">or</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">next</span><span class="c"> </span><span class="c">value</span><span class="c"> </span><span class="c">together</span><span class="c"> </span><span class="c">with</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">rest</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">sequence.</span>
<span class="l">3: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fasyst11', 1)" onmouseover="showTip(event, 'fasyst11', 1)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fasyst12', 2)" onmouseover="showTip(event, 'fasyst12', 2)" class="i">Async</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fasyst13', 3)" onmouseover="showTip(event, 'fasyst13', 3)" class="i">AsyncSeqInner</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span><span class="o">&gt;</span> 
<span class="l">4: </span><span class="k">and</span> <span onmouseout="hideTip(event, 'fasyst13', 4)" onmouseover="showTip(event, 'fasyst13', 4)" class="i">AsyncSeqInner</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">=</span>
<span class="l">5: </span>  | <span onmouseout="hideTip(event, 'fasyst14', 5)" onmouseover="showTip(event, 'fasyst14', 5)" class="i">Nil</span>
<span class="l">6: </span>  | <span onmouseout="hideTip(event, 'fasyst15', 6)" onmouseover="showTip(event, 'fasyst15', 6)" class="i">Cons</span> <span class="k">of</span> <span class="o">&#39;</span><span class="i">T</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fasyst11', 7)" onmouseover="showTip(event, 'fasyst11', 7)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span></pre>

<p>An <em>asynchronous sequence</em> is an asynchronous computation. When started, it eventually produces
  a value of type <code>AsyncSeqInner&lt;'T&gt;</code>. The generated value is either <code>Nil</code> 
  representing the end of the sequence or <code>Cons</code> carrying a value together with the 
  <em>tail</em> of the sequence. The tail is again an asynchronous sequence - it can be started to 
  get the next element of the sequence (if there are any) or it can be disposed if we don't need any
  further elements. To summarize - when programming with asynchronous sequences, the consumer is 
  in control of the evaluation:</p>
<ul class="spaces">
<li>When using <code>AsyncSeq&lt;'T&gt;</code>, we can <em>pull</em> elements from the sequence 
  (although the <em>pull</em> operation is asynchronous and may take some time before it completes). 
  This approach is more suitable if the source that generates the values can be controlled - for example, 
  we can ask a web crawler for a next bulk of pages or we can ask a source that reads file 
  for the next 1kB of data. </li>
<li>On the other hand, sources that cannot be controlled (such as clicks in the user-interface or 
  incomming messages) are better represented using <code>IObservable&lt;'T&gt;</code>. </li>
</ul>
<p>There are some ways of converting between these two models, but we'll discuss that later.
  First, let's take a look at some examples. Creating values of type <code>AsyncSeq&lt;'T&gt;</code>
  directly would be a bit cumbersome. Fortunately, we can use the computation expression syntax...</p>

<h2>Creating asynchronous sequences</h2>

<p>The code to create asynchronous sequence is very similar to standard F# asynchronous workflows.
  The only difference is that asynchronous sequence can return multiple values using the 
  <code>yield</code> keyword. The following snippet creates a simple asynchronous sequence.
  When started, it returns 1 after 1 second. When the returned <em>tail</em> is started,
  it returns 2 after 1 more second. Finally, starting the newly returned tail will return
  <code>Nil</code> immediately:</p>

<pre class="fssnip">
<span class="l">1: </span><span class="c">//</span><span class="c"> </span><span class="c">When</span><span class="c"> </span><span class="c">accessed,</span><span class="c"> </span><span class="c">generates</span><span class="c"> </span><span class="c">numbers</span><span class="c"> </span><span class="c">1</span><span class="c"> </span><span class="c">and</span><span class="c"> </span><span class="c">2.</span><span class="c"> </span><span class="c">The</span><span class="c"> </span><span class="c">number</span><span class="c"> </span>
<span class="l">2: </span><span class="c">//</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">returned</span><span class="c"> </span><span class="c">1</span><span class="c"> </span><span class="c">second</span><span class="c"> </span><span class="c">after</span><span class="c"> </span><span class="c">value</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">requested.</span>
<span class="l">3: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fasyst16', 8)" onmouseover="showTip(event, 'fasyst16', 8)" class="i">oneTwo</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fasyst17', 9)" onmouseover="showTip(event, 'fasyst17', 9)" class="i">asyncSeq</span> { 
<span class="l">4: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fasyst12', 10)" onmouseover="showTip(event, 'fasyst12', 10)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst18', 11)" onmouseover="showTip(event, 'fasyst18', 11)" class="i">Sleep</span>(<span class="n">1000</span>)
<span class="l">5: </span>  <span class="k">yield</span> <span class="n">1</span>
<span class="l">6: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fasyst12', 12)" onmouseover="showTip(event, 'fasyst12', 12)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst18', 13)" onmouseover="showTip(event, 'fasyst18', 13)" class="i">Sleep</span>(<span class="n">1000</span>)
<span class="l">7: </span>  <span class="k">yield</span> <span class="n">2</span> }</pre>

<p>The <code>asyncSeq { .. }</code> block can contain the usual syntax of asynchronous workflows.
  In the example above, we use <code>do!</code> together with the standard <code>Async.Sleep</code> 
  member to pause the asynchronous sequence for 1 second.</p>
<p>This example shows that <em>asynchronous sequences</em> fit naturally extremely well with 
  <em>asynchronous workflows</em>. This is possible because the right-hand-side of <code>let!</code> 
  and <code>do!</code> is of type <code>Async&lt;'T&gt;</code> as opposed to <code>AsyncSeq&lt;'T&gt;</code> 
  (which would be the case for a usual <em>monad</em>).</p>

<p>To can get a better understanding of what syntax is allowed inside the <code>asyncSeq { .. }</code>
  block, let's look at the type signature of the <code>AsyncSeqBuilder</code> computation builder.
  The listing omits some members (for exception handling and <code>while</code> loop), but it shows
  the essence of asynchronous sequences:</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fasyst21', 1)" onmouseover="showTip(event, 'fasyst21', 1)" class="i">AsyncSeqBuilder</span> <span class="o">=</span>
<span class="l"> 2: </span>  <span class="c">//</span><span class="c"> </span><span class="c">Waits</span><span class="c"> </span><span class="c">for</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">result</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">a</span><span class="c"> </span><span class="c">single</span><span class="c"> </span><span class="c">asynchronous</span><span class="c"> </span>
<span class="l"> 3: </span>  <span class="c">//</span><span class="c"> </span><span class="c">operation</span><span class="c"> </span><span class="c">and</span><span class="c"> </span><span class="c">then</span><span class="c"> </span><span class="c">continues</span><span class="c"> </span><span class="c">generating</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">sequence</span>
<span class="l"> 4: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fasyst22', 2)" onmouseover="showTip(event, 'fasyst22', 2)" class="i">Bind</span>  <span class="o">:</span> <span onmouseout="hideTip(event, 'fasyst23', 3)" onmouseover="showTip(event, 'fasyst23', 3)" class="i">Async</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">*</span> (<span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 4)" onmouseover="showTip(event, 'fasyst24', 4)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">U</span><span class="o">&gt;</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 5)" onmouseover="showTip(event, 'fasyst24', 5)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">U</span><span class="o">&gt;</span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>  <span class="c">//</span><span class="c"> </span><span class="c">For</span><span class="c"> </span><span class="c">every</span><span class="c"> </span><span class="c">element</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">input</span><span class="c"> </span><span class="c">(asynchronous)</span><span class="c"> </span><span class="c">sequence,</span><span class="c"> </span>
<span class="l"> 7: </span>  <span class="c">//</span><span class="c"> </span><span class="c">yield</span><span class="c"> </span><span class="c">all</span><span class="c"> </span><span class="c">elements</span><span class="c"> </span><span class="c">generated</span><span class="c"> </span><span class="c">by</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">body</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">for</span><span class="c"> </span><span class="c">loop</span>
<span class="l"> 8: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fasyst25', 6)" onmouseover="showTip(event, 'fasyst25', 6)" class="i">For</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fasyst24', 7)" onmouseover="showTip(event, 'fasyst24', 7)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">*</span> (<span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 8)" onmouseover="showTip(event, 'fasyst24', 8)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">TResult</span><span class="o">&gt;</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 9)" onmouseover="showTip(event, 'fasyst24', 9)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">TResult</span><span class="o">&gt;</span>
<span class="l"> 9: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fasyst26', 10)" onmouseover="showTip(event, 'fasyst26', 10)" class="i">For</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fasyst27', 11)" onmouseover="showTip(event, 'fasyst27', 11)" class="i">seq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span>      <span class="o">*</span> (<span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 12)" onmouseover="showTip(event, 'fasyst24', 12)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">TResult</span><span class="o">&gt;</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 13)" onmouseover="showTip(event, 'fasyst24', 13)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">TResult</span><span class="o">&gt;</span>
<span class="l">10: </span>
<span class="l">11: </span>  <span class="c">//</span><span class="c"> </span><span class="c">Yield</span><span class="c"> </span><span class="c">single/zero</span><span class="c"> </span><span class="c">elements</span><span class="c"> </span><span class="c">and</span><span class="c"> </span><span class="c">concatenation</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">sequences</span>
<span class="l">12: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fasyst28', 14)" onmouseover="showTip(event, 'fasyst28', 14)" class="i">Yield</span> <span class="o">:</span> <span class="o">&#39;</span><span class="i">T</span>   <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 15)" onmouseover="showTip(event, 'fasyst24', 15)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span>
<span class="l">13: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fasyst29', 16)" onmouseover="showTip(event, 'fasyst29', 16)" class="i">Zero</span>  <span class="o">:</span> <span onmouseout="hideTip(event, 'fasyst210', 17)" onmouseover="showTip(event, 'fasyst210', 17)" class="i">unit</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 18)" onmouseover="showTip(event, 'fasyst24', 18)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span>
<span class="l">14: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fasyst211', 19)" onmouseover="showTip(event, 'fasyst211', 19)" class="i">Combine</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fasyst24', 20)" onmouseover="showTip(event, 'fasyst24', 20)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fasyst24', 21)" onmouseover="showTip(event, 'fasyst24', 21)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 22)" onmouseover="showTip(event, 'fasyst24', 22)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span>
<span class="l">15: </span>
<span class="l">16: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fasyst212', 23)" onmouseover="showTip(event, 'fasyst212', 23)" class="i">Microsoft</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst213', 24)" onmouseover="showTip(event, 'fasyst213', 24)" class="i">FSharp</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst214', 25)" onmouseover="showTip(event, 'fasyst214', 25)" class="i">Control</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst215', 26)" onmouseover="showTip(event, 'fasyst215', 26)" class="i">AsyncBuilder</span> <span class="k">with</span>
<span class="l">17: </span>  <span class="c">//</span><span class="c"> </span><span class="c">For</span><span class="c"> </span><span class="c">every</span><span class="c"> </span><span class="c">element</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">input</span><span class="c"> </span><span class="c">asynchronous</span><span class="c"> </span><span class="c">sequence,</span>
<span class="l">18: </span>  <span class="c">//</span><span class="c"> </span><span class="c">perform</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">specified</span><span class="c"> </span><span class="c">asynchronous</span><span class="c"> </span><span class="c">workflow</span>
<span class="l">19: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fasyst216', 27)" onmouseover="showTip(event, 'fasyst216', 27)" class="i">For</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fasyst24', 28)" onmouseover="showTip(event, 'fasyst24', 28)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">*</span> (<span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst23', 29)" onmouseover="showTip(event, 'fasyst23', 29)" class="i">Async</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fasyst210', 30)" onmouseover="showTip(event, 'fasyst210', 30)" class="i">unit</span><span class="o">&gt;</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst23', 31)" onmouseover="showTip(event, 'fasyst23', 31)" class="i">Async</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fasyst210', 32)" onmouseover="showTip(event, 'fasyst210', 32)" class="i">unit</span><span class="o">&gt;</span></pre>

<p>As already mentioned, the <code>Bind</code> operation is unusual, because it takes 
  <code>Async&lt;'T&gt;</code>. It creates an asynchronous sequence that starts the workflow,
  then calls the specified function and then continues yielding elements using the generated
  asynchronous sequence.</p>

<p>If we want to create an asynchronous sequence that uses all elements of another 
  asynchronous sequence, we need to use the <code>for</code> syntax (you'll find some 
  examples in the next section). This is similar to how usual <em>sequence expressions</em>
  work. When you want to return all elements of some other sequence, you can write
  <code>for</code> loop containing <code>yield</code>. Alternatively, you can also write
  <code>yield!</code>, which is also supported for asynchronous sequences. The definition
  uses overloading, so it allows iterating over both synchronous and asynchronous sequences.</p>

<p>The listing also adds an overloaded <code>For</code> member to the computation builder for
  standard F# asynchronous workflows (the <code>AsyncBuilder</code> type). This allows us to 
  easily consume an asynchronous sequence (I'll explain how this work when we look at an example 
  later).</p>

<h3>Downloading web pages sequentially</h3>
<p>To get started with asynchronous sequences, 
  the following example creates a computation that downloads a list of web pages a 
  and returns their URL together with the size of the downloaded HTML content. The web pages
  are <em>not</em> downloaded in parallel - we start downloading the next page only after the previous
  one was downloaded and consumed by the caller.</p>
<p>If the list contained millions of URLs and the
  caller only needed the first three, we wouldn't want to waste all our bandwidth. However,
  it may be a good idea to process <em>a few</em> pages in advance and store them in some buffer
  - this can be easily done and you can find examples in the source code at the end of this article.</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fasyst19', 14)" onmouseover="showTip(event, 'fasyst19', 14)" class="i">urls</span> <span class="o">=</span> 
<span class="l"> 2: </span>  [ <span class="s">&quot;</span><span class="s">http</span><span class="s">:</span><span class="s">/</span><span class="s">/</span><span class="s">bing</span><span class="s">.</span><span class="s">com</span><span class="s">&quot;</span>; <span class="s">&quot;</span><span class="s">http</span><span class="s">:</span><span class="s">/</span><span class="s">/</span><span class="s">yahoo</span><span class="s">.</span><span class="s">com</span><span class="s">&quot;</span>; 
<span class="l"> 3: </span>    <span class="s">&quot;</span><span class="s">http</span><span class="s">:</span><span class="s">/</span><span class="s">/</span><span class="s">google</span><span class="s">.</span><span class="s">com</span><span class="s">&quot;</span>; <span class="s">&quot;</span><span class="s">http</span><span class="s">:</span><span class="s">/</span><span class="s">/</span><span class="s">msn</span><span class="s">.</span><span class="s">com</span><span class="s">&quot;</span> ]
<span class="l"> 4: </span>
<span class="l"> 5: </span><span class="c">//</span><span class="c"> </span><span class="c">Asynchronous</span><span class="c"> </span><span class="c">sequence</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">returns</span><span class="c"> </span><span class="c">URLs</span><span class="c"> </span><span class="c">and</span><span class="c"> </span><span class="c">lengths</span>
<span class="l"> 6: </span><span class="c">//</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">downloaded</span><span class="c"> </span><span class="c">HTML.</span><span class="c"> </span><span class="c">Web</span><span class="c"> </span><span class="c">pages</span><span class="c"> </span><span class="c">from</span><span class="c"> </span><span class="c">a</span><span class="c"> </span><span class="c">given</span><span class="c"> </span><span class="c">list</span>
<span class="l"> 7: </span><span class="c">//</span><span class="c"> </span><span class="c">are</span><span class="c"> </span><span class="c">downloaded</span><span class="c"> </span><span class="c">asynchronously</span><span class="c"> </span><span class="c">in</span><span class="c"> </span><span class="c">sequence.</span>
<span class="l"> 8: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fasyst110', 15)" onmouseover="showTip(event, 'fasyst110', 15)" class="i">pages</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fasyst17', 16)" onmouseover="showTip(event, 'fasyst17', 16)" class="i">asyncSeq</span> {
<span class="l"> 9: </span>  <span class="k">use</span> <span onmouseout="hideTip(event, 'fasyst111', 17)" onmouseover="showTip(event, 'fasyst111', 17)" class="i">wc</span> <span class="o">=</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fasyst112', 18)" onmouseover="showTip(event, 'fasyst112', 18)" class="i">WebClient</span>()
<span class="l">10: </span>  <span class="k">for</span> <span onmouseout="hideTip(event, 'fasyst113', 19)" onmouseover="showTip(event, 'fasyst113', 19)" class="i">url</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fasyst19', 20)" onmouseover="showTip(event, 'fasyst19', 20)" class="i">urls</span> <span class="k">do</span>
<span class="l">11: </span>    <span class="k">try</span>
<span class="l">12: </span>      <span class="k">let!</span> <span onmouseout="hideTip(event, 'fasyst114', 21)" onmouseover="showTip(event, 'fasyst114', 21)" class="i">html</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fasyst111', 22)" onmouseover="showTip(event, 'fasyst111', 22)" class="i">wc</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst115', 23)" onmouseover="showTip(event, 'fasyst115', 23)" class="i">AsyncDownloadString</span>(<span onmouseout="hideTip(event, 'fasyst116', 24)" onmouseover="showTip(event, 'fasyst116', 24)" class="i">Uri</span>(<span onmouseout="hideTip(event, 'fasyst113', 25)" onmouseover="showTip(event, 'fasyst113', 25)" class="i">url</span>))
<span class="l">13: </span>      <span class="k">yield</span> <span onmouseout="hideTip(event, 'fasyst113', 26)" onmouseover="showTip(event, 'fasyst113', 26)" class="i">url</span>, <span class="i">html</span><span class="o">.</span><span class="i">Length</span> 
<span class="l">14: </span>    <span class="k">with</span> _ <span class="k">-&gt;</span> 
<span class="l">15: </span>      <span class="k">yield</span> <span onmouseout="hideTip(event, 'fasyst113', 27)" onmouseover="showTip(event, 'fasyst113', 27)" class="i">url</span>, <span class="o">-</span><span class="n">1</span> }    </pre>

<p>The <code>asyncSeq { .. }</code> block iterates over a (synchronous) list of URLs using a <code>for</code>
  loop. The body of the loop is an asynchronous sequence. We use <code>try .. with</code> to handle
  exceptions that may occur when evaluating the computation. Inside the exception handler, we download
  a single page and return its URL and size. If an exception occurs, the URL is still returned, but 
  with -1 as the size.</p>

<p>Now that we have an asynchronous sequence, let's look how to consume it. The elements of the sequence
  are evaluated asynchronously, which may take a long time, so we need to use <code>async { .. }</code> 
  to avoid blocking threads (the type <code>AsyncSeq&lt;'T&gt;</code> does not implement the
  <code>seq&lt;'T&gt;</code> interface):</p>

<pre class="fssnip">
<span class="l">1: </span><span class="c">//</span><span class="c"> </span><span class="c">Asynchronous</span><span class="c"> </span><span class="c">workflow</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">prints</span><span class="c"> </span><span class="c">results</span>
<span class="l">2: </span><span onmouseout="hideTip(event, 'fasyst117', 28)" onmouseover="showTip(event, 'fasyst117', 28)" class="i">async</span> {
<span class="l">3: </span>  <span class="k">for</span> <span onmouseout="hideTip(event, 'fasyst113', 29)" onmouseover="showTip(event, 'fasyst113', 29)" class="i">url</span>, <span onmouseout="hideTip(event, 'fasyst118', 30)" onmouseover="showTip(event, 'fasyst118', 30)" class="i">length</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fasyst110', 31)" onmouseover="showTip(event, 'fasyst110', 31)" class="i">pages</span> <span class="k">do</span>
<span class="l">4: </span>    <span onmouseout="hideTip(event, 'fasyst119', 32)" onmouseover="showTip(event, 'fasyst119', 32)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">%</span><span class="s">s</span><span class="s"> </span><span class="s">(</span><span class="s">%</span><span class="s">d</span><span class="s">)</span><span class="s">&quot;</span> <span class="i">url</span> <span class="i">length</span> }
<span class="l">5: </span><span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fasyst12', 33)" onmouseover="showTip(event, 'fasyst12', 33)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst120', 34)" onmouseover="showTip(event, 'fasyst120', 34)" class="i">Start</span></pre>

<p>This snippet uses the overloaded <code>for</code> loop that is added to the standard
  F# asynchronous workflow (as discussed earlier). When evaluating the loop, the workflow
  calls the <code>AsyncSeq&lt;'T&gt</code> value to get the first element and a tail. Then 
  it evaluates the body of the <code>for</code> loop (which is itself asynchronous and may
  take some time). When the body completes, the <code>for</code> loop calls the <code>AsyncSeq&lt;'T&gt;</code>
  that was returned previously as a tail.</p>

<p>This means that the elements of asynchronous sequence are generated on-demand. As with standard
  F# async workflows, there is <strong>no implicit parallelism</strong>. Parallelising a program
  is a separate concern and it can be easily done using a combinator that creates an asynchronous 
  sequence that evaluates certain number of elements in advance and keeps them in a buffer.</p>

<p>In the above example, the body simply prints the element generated by the sequence and then
  immediately asks for the next element, so there is no room (or need) for parallelism.</p>

<h2>Processing asynchronous sequences</h2>
<p>The previous section demonstrated how to create asynchronous sequences explicitly using the 
  <code>asyncSeq { .. }</code> computation builder. This is similar to constructing ordinary 
  sequences using the <code>seq { .. }</code> notation. Once we have an asynchronous sequence,
  we can process it using several useful higher-order functions that implement filtering, projection
  and other useful operation. Many of the functions from the <code>Seq</code> module can be 
  provided for asynchronous sequences too.</p>

<p>The following example demonstrates several of combinators. It takes the <code>pages</code> asynchronous
  sequence from the previous section and gets URLs of pages that are larger than 50kB. Then it 
  prints the URLs to the console:</p>

<pre class="fssnip">
<span class="l">1: </span><span class="c">//</span><span class="c"> </span><span class="c">Print</span><span class="c"> </span><span class="c">URL</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">pages</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">are</span><span class="c"> </span><span class="c">smaller</span><span class="c"> </span><span class="c">than</span><span class="c"> </span><span class="c">50k</span>
<span class="l">2: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fasyst121', 35)" onmouseover="showTip(event, 'fasyst121', 35)" class="i">printPages</span> <span class="o">=</span>
<span class="l">3: </span>  <span onmouseout="hideTip(event, 'fasyst110', 36)" onmouseover="showTip(event, 'fasyst110', 36)" class="i">pages</span> 
<span class="l">4: </span>  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fasyst122', 37)" onmouseover="showTip(event, 'fasyst122', 37)" class="i">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst123', 38)" onmouseover="showTip(event, 'fasyst123', 38)" class="i">filter</span> (<span class="k">fun</span> (_, <span onmouseout="hideTip(event, 'fasyst124', 39)" onmouseover="showTip(event, 'fasyst124', 39)" class="i">len</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst124', 40)" onmouseover="showTip(event, 'fasyst124', 40)" class="i">len</span> <span class="o">&lt;</span> <span class="n">50000</span>)
<span class="l">5: </span>  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fasyst122', 41)" onmouseover="showTip(event, 'fasyst122', 41)" class="i">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst125', 42)" onmouseover="showTip(event, 'fasyst125', 42)" class="i">map</span> <span onmouseout="hideTip(event, 'fasyst126', 43)" onmouseover="showTip(event, 'fasyst126', 43)" class="i">fst</span>
<span class="l">6: </span>  <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fasyst122', 44)" onmouseover="showTip(event, 'fasyst122', 44)" class="i">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst127', 45)" onmouseover="showTip(event, 'fasyst127', 45)" class="i">iter</span> (<span onmouseout="hideTip(event, 'fasyst119', 46)" onmouseover="showTip(event, 'fasyst119', 46)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">%</span><span class="s">s</span><span class="s">&quot;</span>)
<span class="l">7: </span>
<span class="l">8: </span><span onmouseout="hideTip(event, 'fasyst121', 47)" onmouseover="showTip(event, 'fasyst121', 47)" class="i">printPages</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fasyst12', 48)" onmouseover="showTip(event, 'fasyst12', 48)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst120', 49)" onmouseover="showTip(event, 'fasyst120', 49)" class="i">Start</span></pre>

<p>In this example, the functions used as arguments to <code>filter</code>, <code>map</code> and <code>iter</code>
  are synchronous functions that complete immediately. As you can see using the tool tips, 
  the type of <code>map</code> and <code>filter</code> is what you would expect - they take
  <code>AsyncSeq&lt;'T&gt;</code> and return another <code>AsyncSeq&lt;'R&gt;</code>. The type
  of <code>iter</code> is more interesting. It returns <code>Async&lt;unti&gt;</code>, so we can 
  execute the operation in an asynchronous workflow and wait until the iteration is completed
  (This is the same behavior as <code>Seq.iter</code>, but it differs from similar operation
  for <code>IObservable&lt;'T&gt;</code> - the <code>Observable.add</code> function returns
  immediately.)</p>

<p>The complete library (available at the end of the article) also provides asynchronous versions of 
  most of the operations. For example, if the input asynchronous sequence contained just URLs, we would
  need to (asynchronously) download the web page and then test whether the length is less than 50kB.
  This could be done using <code>filterAsync</code>, which is similar to <code>filter</code> with the
  only difference that the predicate (given as the first argument) is asynchronous function. </p>

<p>Combinators such as <code>filter</code> and <code>filterAsync</code> are very easy to implement
  using the <code>asyncSeq</code> computation builder:</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="c">///</span><span class="c"> </span><span class="c">Return</span><span class="c"> </span><span class="c">elements</span><span class="c"> </span><span class="c">for</span><span class="c"> </span><span class="c">which</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">predicate</span><span class="c"> </span><span class="c">returns</span><span class="c"> </span><span class="c">true</span>
<span class="l"> 2: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fasyst128', 50)" onmouseover="showTip(event, 'fasyst128', 50)" class="i">filter</span> <span onmouseout="hideTip(event, 'fasyst129', 51)" onmouseover="showTip(event, 'fasyst129', 51)" class="i">f</span> (<span onmouseout="hideTip(event, 'fasyst130', 52)" onmouseover="showTip(event, 'fasyst130', 52)" class="i">input</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fasyst122', 53)" onmouseover="showTip(event, 'fasyst122', 53)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fasyst17', 54)" onmouseover="showTip(event, 'fasyst17', 54)" class="i">asyncSeq</span> {
<span class="l"> 3: </span>  <span class="k">for</span> <span onmouseout="hideTip(event, 'fasyst131', 55)" onmouseover="showTip(event, 'fasyst131', 55)" class="i">v</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fasyst130', 56)" onmouseover="showTip(event, 'fasyst130', 56)" class="i">input</span> <span class="k">do</span>
<span class="l"> 4: </span>    <span class="k">if</span> <span onmouseout="hideTip(event, 'fasyst129', 57)" onmouseover="showTip(event, 'fasyst129', 57)" class="i">f</span> <span onmouseout="hideTip(event, 'fasyst131', 58)" onmouseover="showTip(event, 'fasyst131', 58)" class="i">v</span> <span class="k">then</span> <span class="k">yield</span> <span onmouseout="hideTip(event, 'fasyst131', 59)" onmouseover="showTip(event, 'fasyst131', 59)" class="i">v</span> }
<span class="l"> 5: </span>
<span class="l"> 6: </span><span class="c">///</span><span class="c"> </span><span class="c">Return</span><span class="c"> </span><span class="c">elements</span><span class="c"> </span><span class="c">for</span><span class="c"> </span><span class="c">which</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">asynchronous</span><span class="c"> </span><span class="c">predicate</span><span class="c"> </span><span class="c">returns</span><span class="c"> </span><span class="c">true</span>
<span class="l"> 7: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fasyst132', 60)" onmouseover="showTip(event, 'fasyst132', 60)" class="i">filterAsync</span> <span onmouseout="hideTip(event, 'fasyst133', 61)" onmouseover="showTip(event, 'fasyst133', 61)" class="i">f</span> (<span onmouseout="hideTip(event, 'fasyst130', 62)" onmouseover="showTip(event, 'fasyst130', 62)" class="i">input</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fasyst122', 63)" onmouseover="showTip(event, 'fasyst122', 63)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fasyst17', 64)" onmouseover="showTip(event, 'fasyst17', 64)" class="i">asyncSeq</span> {
<span class="l"> 8: </span>  <span class="k">for</span> <span onmouseout="hideTip(event, 'fasyst131', 65)" onmouseover="showTip(event, 'fasyst131', 65)" class="i">v</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fasyst130', 66)" onmouseover="showTip(event, 'fasyst130', 66)" class="i">input</span> <span class="k">do</span>
<span class="l"> 9: </span>    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fasyst134', 67)" onmouseover="showTip(event, 'fasyst134', 67)" class="i">b</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fasyst133', 68)" onmouseover="showTip(event, 'fasyst133', 68)" class="i">f</span> <span onmouseout="hideTip(event, 'fasyst131', 69)" onmouseover="showTip(event, 'fasyst131', 69)" class="i">v</span>
<span class="l">10: </span>    <span class="k">if</span> <span onmouseout="hideTip(event, 'fasyst134', 70)" onmouseover="showTip(event, 'fasyst134', 70)" class="i">b</span> <span class="k">then</span> <span class="k">yield</span> <span onmouseout="hideTip(event, 'fasyst131', 71)" onmouseover="showTip(event, 'fasyst131', 71)" class="i">v</span> }</pre>

<p>The two functions demonstrate a great aspect of the programming model based on asynchronous 
  sequences. We can reuse many of the standard patterns that are useful when working with either
  normal <em>sequence expressions</em> or when using <em>asynchronous workflows</em>. The definition
  of <code>filter</code> is essentially the same as what you'd write when implementing <code>Seq.filter</code>. </p>
<p>In these examples, the <code>asyncSeq { .. }</code> block contains an asynchronous <code>for</code> loop
  that iterates over another asynchronous sequence. In the body, it yields it performs some operation.
  In the second case, the operation is performed asynchronously using <code>let!</code>. When it completes,
  the body (optionally) uses <code>yield</code> to generate the next value. 
  When the consumer of the sequence returned by <code>filter</code> or <code>filterAsync</code> requests
  the next element, the sequence resumes, asks the <code>input</code> sequence for the next element
  and loops until it finds an element matching the predicate.</p>

<p>I will not discuss all combinators that are implemented in the <code>AsyncSeq</code> module. In general,
  the module implements most of the functionality that is available in the standard <code>Seq</code> module
  (and each function is well documented). However, the following listing shows a few declarations of
  interesting and useful functions:</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="c">//</span><span class="c"> </span><span class="c">Aggregate</span><span class="c"> </span><span class="c">all</span><span class="c"> </span><span class="c">elements</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">async</span><span class="c"> </span><span class="c">sequence</span><span class="c"> </span><span class="c">using</span><span class="c"> </span><span class="c">async</span><span class="c"> </span><span class="c">function</span><span class="c"> </span>
<span class="l"> 2: </span><span class="c">//</span><span class="c"> </span><span class="c">and</span><span class="c"> </span><span class="c">return</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">result</span><span class="c"> </span><span class="c">(as</span><span class="c"> </span><span class="c">an</span><span class="c"> </span><span class="c">asynchronous</span><span class="c"> </span><span class="c">workflow)</span>
<span class="l"> 3: </span><span class="k">val</span> <span onmouseout="hideTip(event, 'fasyst217', 33)" onmouseover="showTip(event, 'fasyst217', 33)" class="i">foldAsync</span> <span class="o">:</span> (<span class="o">&#39;</span><span class="i">S</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst23', 34)" onmouseover="showTip(event, 'fasyst23', 34)" class="i">Async</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">S</span><span class="o">&gt;</span>) <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">S</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 35)" onmouseover="showTip(event, 'fasyst24', 35)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst23', 36)" onmouseover="showTip(event, 'fasyst23', 36)" class="i">Async</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">S</span><span class="o">&gt;</span>
<span class="l"> 4: </span>
<span class="l"> 5: </span><span class="c">//</span><span class="c"> </span><span class="c">Aggregate</span><span class="c"> </span><span class="c">elements</span><span class="c"> </span><span class="c">and</span><span class="c"> </span><span class="c">yield</span><span class="c"> </span><span class="c">immediate</span><span class="c"> </span><span class="c">results</span><span class="c"> </span><span class="c">as</span><span class="c"> </span><span class="c">an</span><span class="c"> </span><span class="c">async</span><span class="c"> </span><span class="c">sequence</span>
<span class="l"> 6: </span><span class="c">//</span><span class="c"> </span><span class="c">(The</span><span class="c"> </span><span class="c">input</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">accessed</span><span class="c"> </span><span class="c">lazily</span><span class="c"> </span><span class="c">as</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">result</span><span class="c"> </span><span class="c">sequence</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">evaluated)</span>
<span class="l"> 7: </span><span class="k">val</span> <span onmouseout="hideTip(event, 'fasyst218', 37)" onmouseover="showTip(event, 'fasyst218', 37)" class="i">scanAsync</span> <span class="o">:</span> (<span class="o">&#39;</span><span class="i">S</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst23', 38)" onmouseover="showTip(event, 'fasyst23', 38)" class="i">Async</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">S</span><span class="o">&gt;</span>) <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">S</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 39)" onmouseover="showTip(event, 'fasyst24', 39)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 40)" onmouseover="showTip(event, 'fasyst24', 40)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">S</span><span class="o">&gt;</span>
<span class="l"> 8: </span>
<span class="l"> 9: </span><span class="c">//</span><span class="c"> </span><span class="c">Same</span><span class="c"> </span><span class="c">as</span><span class="c"> </span><span class="c">previous</span><span class="c"> </span><span class="c">functions,</span><span class="c"> </span><span class="c">but</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">aggregating</span><span class="c"> </span><span class="c">function</span><span class="c"> </span><span class="c">is</span><span class="c"> </span><span class="c">synchronous</span>
<span class="l">10: </span><span class="k">val</span> <span onmouseout="hideTip(event, 'fasyst219', 41)" onmouseover="showTip(event, 'fasyst219', 41)" class="i">fold</span> <span class="o">:</span> (<span class="o">&#39;</span><span class="i">S</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">S</span>) <span class="k">-&gt;</span>  <span class="o">&#39;</span><span class="i">S</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 42)" onmouseover="showTip(event, 'fasyst24', 42)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst23', 43)" onmouseover="showTip(event, 'fasyst23', 43)" class="i">Async</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">S</span><span class="o">&gt;</span>
<span class="l">11: </span><span class="k">val</span> <span onmouseout="hideTip(event, 'fasyst220', 44)" onmouseover="showTip(event, 'fasyst220', 44)" class="i">scan</span> <span class="o">:</span> (<span class="o">&#39;</span><span class="i">S</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">S</span>) <span class="k">-&gt;</span>  <span class="o">&#39;</span><span class="i">S</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 45)" onmouseover="showTip(event, 'fasyst24', 45)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 46)" onmouseover="showTip(event, 'fasyst24', 46)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">S</span><span class="o">&gt;</span>
<span class="l">12: </span>
<span class="l">13: </span><span class="c">//</span><span class="c"> </span><span class="c">Synchronous</span><span class="c"> </span><span class="c">and</span><span class="c"> </span><span class="c">asynchronous</span><span class="c"> </span><span class="c">version</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">a</span><span class="c"> </span><span class="c">function</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">returns</span><span class="c"> </span>
<span class="l">14: </span><span class="c">//</span><span class="c"> </span><span class="c">elements</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">input</span><span class="c"> </span><span class="c">sequence</span><span class="c"> </span><span class="c">(lazily)</span><span class="c"> </span><span class="c">while</span><span class="c"> </span><span class="c">a</span><span class="c"> </span><span class="c">predicate</span><span class="c"> </span><span class="c">holds</span>
<span class="l">15: </span><span class="k">val</span> <span onmouseout="hideTip(event, 'fasyst221', 47)" onmouseover="showTip(event, 'fasyst221', 47)" class="i">takeWhileAsync</span> <span class="o">:</span> (<span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst23', 48)" onmouseover="showTip(event, 'fasyst23', 48)" class="i">Async</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fasyst222', 49)" onmouseover="showTip(event, 'fasyst222', 49)" class="i">bool</span><span class="o">&gt;</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 50)" onmouseover="showTip(event, 'fasyst24', 50)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 51)" onmouseover="showTip(event, 'fasyst24', 51)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span>
<span class="l">16: </span><span class="k">val</span> <span onmouseout="hideTip(event, 'fasyst223', 52)" onmouseover="showTip(event, 'fasyst223', 52)" class="i">takeWhile</span> <span class="o">:</span> (<span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst222', 53)" onmouseover="showTip(event, 'fasyst222', 53)" class="i">bool</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 54)" onmouseover="showTip(event, 'fasyst24', 54)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst24', 55)" onmouseover="showTip(event, 'fasyst24', 55)" class="i">AsyncSeq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span></pre>

<p>Two very useful functions in functional programming are <code>fold</code> and <code>scan</code>. In our setting,
  <code>fold</code> aggregates an asynchronous sequence using the specified function and returns an asynchronous
  workflow that produces the aggregate when the asynchronous sequence ends. The <code>scan</code> function is similar,
  but it generates an asynchronous sequence of immediate results. As you can see, there are two versions of both
  functions: one that uses synchronous and one that uses asynchronous aggregation function.</p>

<h2>Implementing sequential web crawler</h2>
<p>Web crawlers are popular examples when demonstrating asynchronous programming in F#, so I'll use the same problem
  to implement a larger example based on asynchronous sequences. The usual web crawler examples in F# demonstrate
  that you can easily run a large number of asynchronous operations in parallel. This example focuses on something else:</p>

<ul class="spaces">
  <li>We use asynchronous sequence to control the web crawler. The crawler continues processing only
    when the consumer is ready to handle the next value. This means that asynchronous sequences
    <strong>give the caller a way to control the source</strong>.</li>
 
  <li>The code that consumes pages produced by the crawler uses just the <code>AsyncSeq&lt;'T&gt;</code>
    interface and it can use the functions designed for working with it without knowing how the crawler
    works. This means that asynchronous sequences are <strong>a useful abstraction representing asynchronously
    produced values</strong>.</li>
</ul>
 
<p>The crawler in this simple exeample is fully sequential - it downloads a single page, passes it to the 
  consumer and then waits until the consumer asks for the next page. We could improve the crawler by downloading
  several pages in advance (in parallel) and storing them in a buffer. You can find this feature in the complete
  source code at the end of the article. The important point is that the caller can still control the crawler
  and can still use the unified interface.</p>

<p>The following snippet implements a function <code>randomCrawl</code> that takes an initial URL and then 
  continues crawling from this URL. It is implemented using a recursive <code>loop</code> function. If it 
  reaches a page that was not visited before, it returns the URL together with an extracted title and then
  recursively visits all pages referenced from the current document. The code following <code>yield</code>
  will be executed only after the consumer processes the first value and asks for another:</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="c">///</span><span class="c"> </span><span class="c">Crawl</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">internet</span><span class="c"> </span><span class="c">starting</span><span class="c"> </span><span class="c">from</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">specified</span><span class="c"> </span><span class="c">page.</span>
<span class="l"> 2: </span><span class="c">///</span><span class="c"> </span><span class="c">From</span><span class="c"> </span><span class="c">each</span><span class="c"> </span><span class="c">page</span><span class="c"> </span><span class="c">follow</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">first</span><span class="c"> </span><span class="c">not-yet-visited</span><span class="c"> </span><span class="c">page.</span>
<span class="l"> 3: </span><span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'fasyst135', 72)" onmouseover="showTip(event, 'fasyst135', 72)" class="i">randomCrawl</span> <span onmouseout="hideTip(event, 'fasyst113', 73)" onmouseover="showTip(event, 'fasyst113', 73)" class="i">url</span> <span class="o">=</span> 
<span class="l"> 4: </span>  <span class="k">let</span> <span onmouseout="hideTip(event, 'fasyst136', 74)" onmouseover="showTip(event, 'fasyst136', 74)" class="i">visited</span> <span class="o">=</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fasyst137', 75)" onmouseover="showTip(event, 'fasyst137', 75)" class="i">System</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst138', 76)" onmouseover="showTip(event, 'fasyst138', 76)" class="i">Collections</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst139', 77)" onmouseover="showTip(event, 'fasyst139', 77)" class="i">Generic</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst140', 78)" onmouseover="showTip(event, 'fasyst140', 78)" class="i">HashSet</span><span class="o">&lt;</span>_<span class="o">&gt;</span>()
<span class="l"> 5: </span>
<span class="l"> 6: </span>  <span class="c">//</span><span class="c"> </span><span class="c">Visits</span><span class="c"> </span><span class="c">page</span><span class="c"> </span><span class="c">and</span><span class="c"> </span><span class="c">then</span><span class="c"> </span><span class="c">recursively</span><span class="c"> </span><span class="c">visits</span><span class="c"> </span><span class="c">all</span><span class="c"> </span><span class="c">referenced</span><span class="c"> </span><span class="c">pages</span>
<span class="l"> 7: </span>  <span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'fasyst141', 79)" onmouseover="showTip(event, 'fasyst141', 79)" class="i">loop</span> <span onmouseout="hideTip(event, 'fasyst113', 80)" onmouseover="showTip(event, 'fasyst113', 80)" class="i">url</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fasyst17', 81)" onmouseover="showTip(event, 'fasyst17', 81)" class="i">asyncSeq</span> {
<span class="l"> 8: </span>    <span class="k">if</span> <span onmouseout="hideTip(event, 'fasyst136', 82)" onmouseover="showTip(event, 'fasyst136', 82)" class="i">visited</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst142', 83)" onmouseover="showTip(event, 'fasyst142', 83)" class="i">Add</span>(<span onmouseout="hideTip(event, 'fasyst113', 84)" onmouseover="showTip(event, 'fasyst113', 84)" class="i">url</span>) <span class="k">then</span>
<span class="l"> 9: </span>      <span class="k">let!</span> <span onmouseout="hideTip(event, 'fasyst143', 85)" onmouseover="showTip(event, 'fasyst143', 85)" class="i">doc</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fasyst144', 86)" onmouseover="showTip(event, 'fasyst144', 86)" class="i">downloadDocument</span> <span onmouseout="hideTip(event, 'fasyst113', 87)" onmouseover="showTip(event, 'fasyst113', 87)" class="i">url</span>
<span class="l">10: </span>      <span class="k">match</span> <span class="i">doc</span> <span class="k">with</span> 
<span class="l">11: </span>      | <span onmouseout="hideTip(event, 'fasyst145', 88)" onmouseover="showTip(event, 'fasyst145', 88)" class="i">Some</span> <span onmouseout="hideTip(event, 'fasyst146', 89)" onmouseover="showTip(event, 'fasyst146', 89)" class="i">doc</span> <span class="k">-&gt;</span>
<span class="l">12: </span>          <span class="c">//</span><span class="c"> </span><span class="c">Yield</span><span class="c"> </span><span class="c">url</span><span class="c"> </span><span class="c">and</span><span class="c"> </span><span class="c">title</span><span class="c"> </span><span class="c">as</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">next</span><span class="c"> </span><span class="c">element</span>
<span class="l">13: </span>          <span class="k">yield</span> <span onmouseout="hideTip(event, 'fasyst113', 90)" onmouseover="showTip(event, 'fasyst113', 90)" class="i">url</span>, <span onmouseout="hideTip(event, 'fasyst147', 91)" onmouseover="showTip(event, 'fasyst147', 91)" class="i">getTitle</span> <span onmouseout="hideTip(event, 'fasyst146', 92)" onmouseover="showTip(event, 'fasyst146', 92)" class="i">doc</span>
<span class="l">14: </span>          <span class="c">//</span><span class="c"> </span><span class="c">For</span><span class="c"> </span><span class="c">every</span><span class="c"> </span><span class="c">link,</span><span class="c"> </span><span class="c">yield</span><span class="c"> </span><span class="c">all</span><span class="c"> </span><span class="c">referenced</span><span class="c"> </span><span class="c">pages</span><span class="c"> </span><span class="c">too</span>
<span class="l">15: </span>          <span class="k">for</span> <span onmouseout="hideTip(event, 'fasyst148', 93)" onmouseover="showTip(event, 'fasyst148', 93)" class="i">link</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fasyst149', 94)" onmouseover="showTip(event, 'fasyst149', 94)" class="i">extractLinks</span> <span onmouseout="hideTip(event, 'fasyst146', 95)" onmouseover="showTip(event, 'fasyst146', 95)" class="i">doc</span> <span class="k">do</span>
<span class="l">16: </span>            <span class="k">yield!</span> <span onmouseout="hideTip(event, 'fasyst141', 96)" onmouseover="showTip(event, 'fasyst141', 96)" class="i">loop</span> <span class="i">link</span> 
<span class="l">17: </span>      | _ <span class="k">-&gt;</span> () }
<span class="l">18: </span>  <span onmouseout="hideTip(event, 'fasyst141', 97)" onmouseover="showTip(event, 'fasyst141', 97)" class="i">loop</span> <span onmouseout="hideTip(event, 'fasyst113', 98)" onmouseover="showTip(event, 'fasyst113', 98)" class="i">url</span></pre>

<p>The main function in the snippet is written as an ordinary function. It initializes 
  a <code>HashMap&lt;string&gt;</code> for keeping a set of visited URLs. There is no 
  parallelism in the example, so we can use a collection that is not thread-safe. Next, the
  function declares an inner function <code>loop</code> that returns an asynchronous sequence
  and calls it with an initial URL as the argument.</p>

<p>Inside the <code>loop</code> function, we first test if the URL was already visited. If yes,
  the asynchronous sequence immediately ends (returning <code>Nil</code>). Otherwise, it 
  asynchronously downloads the page and, if it succeeds, returns its URL and title.
  After <code>yield</code>, it iterates over all links and returns all pages (asynchronously)
  generated by recursive calls to <code>loop</code>.</p>

<p>Once we created <code>randomCrawl</code>, we can start using the crawler to implement some
  interesting functionality. For example, the following snippet takes first 10 pages that
  are referenced from Bing News and are on another domain:</p>

<pre class="fssnip">
<span class="l">1: </span><span class="c">//</span><span class="c"> </span><span class="c">Use</span><span class="c"> </span><span class="c">AsyncSeq</span><span class="c"> </span><span class="c">combinators</span><span class="c"> </span><span class="c">to</span><span class="c"> </span><span class="c">print</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">titles</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">first</span><span class="c"> </span><span class="c">10</span>
<span class="l">2: </span><span class="c">//</span><span class="c"> </span><span class="c">web</span><span class="c"> </span><span class="c">sites</span><span class="c"> </span><span class="c">that</span><span class="c"> </span><span class="c">are</span><span class="c"> </span><span class="c">from</span><span class="c"> </span><span class="c">other</span><span class="c"> </span><span class="c">domains</span><span class="c"> </span><span class="c">than</span><span class="c"> </span><span class="c">bing.com</span>
<span class="l">3: </span><span onmouseout="hideTip(event, 'fasyst135', 99)" onmouseover="showTip(event, 'fasyst135', 99)" class="i">randomCrawl</span> <span class="s">&quot;</span><span class="s">http</span><span class="s">:</span><span class="s">/</span><span class="s">/</span><span class="s">news</span><span class="s">.</span><span class="s">bing</span><span class="s">.</span><span class="s">com</span><span class="s">&quot;</span>
<span class="l">4: </span><span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fasyst122', 100)" onmouseover="showTip(event, 'fasyst122', 100)" class="i">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst123', 101)" onmouseover="showTip(event, 'fasyst123', 101)" class="i">filter</span> (<span class="k">fun</span> (<span onmouseout="hideTip(event, 'fasyst113', 102)" onmouseover="showTip(event, 'fasyst113', 102)" class="i">url</span>, <span onmouseout="hideTip(event, 'fasyst150', 103)" onmouseover="showTip(event, 'fasyst150', 103)" class="i">title</span>) <span class="k">-&gt;</span> <span class="i">url</span><span class="o">.</span><span class="i">Contains</span>(<span class="s">&quot;</span><span class="s">bing</span><span class="s">.</span><span class="s">com</span><span class="s">&quot;</span>) <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fasyst151', 104)" onmouseover="showTip(event, 'fasyst151', 104)" class="i">not</span>)
<span class="l">5: </span><span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fasyst122', 105)" onmouseover="showTip(event, 'fasyst122', 105)" class="i">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst125', 106)" onmouseover="showTip(event, 'fasyst125', 106)" class="i">map</span> <span onmouseout="hideTip(event, 'fasyst152', 107)" onmouseover="showTip(event, 'fasyst152', 107)" class="i">snd</span>
<span class="l">6: </span><span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fasyst122', 108)" onmouseover="showTip(event, 'fasyst122', 108)" class="i">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst153', 109)" onmouseover="showTip(event, 'fasyst153', 109)" class="i">take</span> <span class="n">10</span>
<span class="l">7: </span><span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fasyst122', 110)" onmouseover="showTip(event, 'fasyst122', 110)" class="i">AsyncSeq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst127', 111)" onmouseover="showTip(event, 'fasyst127', 111)" class="i">iter</span> (<span onmouseout="hideTip(event, 'fasyst119', 112)" onmouseover="showTip(event, 'fasyst119', 112)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">%</span><span class="s">s</span><span class="s">&quot;</span>)
<span class="l">8: </span><span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fasyst12', 113)" onmouseover="showTip(event, 'fasyst12', 113)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst120', 114)" onmouseover="showTip(event, 'fasyst120', 114)" class="i">Start</span></pre>

<p>Implementing the processing using <code>AsyncSeq</code> combinators is quite straightforward. 
  At the end, we use <code>AsyncSeq.iter</code> to perform some action with the results and 
  then start the returned asynchronous workflow using <code>Async.Start</code>.</p>

<p>It is worth repeating that the <em>asynchronous sequence</em> programming model allows us
  to control the crawler easily. When we use <code>AsyncSeq.take</code> to take the first
  10 pages, it means that the crawler will stop after we consume the 10 pages. If we created
  the crawler differently (e.g. as an agent or an asynchronous workflow that writes to some
  thread-safe collection), we would have to program this functionality explicitly. This would
  be done using some control message (for agents), a global variable or a cancellation token.
  In any case, doing the same thing using asynchronous sequences is notably easier.
  </p>

<h2>Exploring other applications</h2>
<p>This article is just a brief introduction to programming with asynchronous sequences. 
  I'll discuss some other interesting applications in the future and you can find several
  more complex examples in the complete source code. Before concluding, I'll briefly mention
  other possible applications and some functionality that the library provides.</p>

<p>One area where asynchronous sequences may be useful is when working with files. For
  example, let's say that we want to read all data from one stream and write them to another
  stream using a buffer of specified size. This can be implemented using a simple 
  asynchronous workflow containing a loop. However, what if we wanted to split the two operations?
  Asynchronous sequences allow us to do exactly that using the following two extension
  members:</p>

<pre class="fssnip">
<span class="l">1: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fasyst224', 56)" onmouseover="showTip(event, 'fasyst224', 56)" class="i">System</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst225', 57)" onmouseover="showTip(event, 'fasyst225', 57)" class="i">IO</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst226', 58)" onmouseover="showTip(event, 'fasyst226', 58)" class="i">Stream</span> <span class="k">with</span>
<span class="l">2: </span>  <span class="c">//</span><span class="c"> </span><span class="c">Read</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">entire</span><span class="c"> </span><span class="c">stream</span><span class="c"> </span><span class="c">as</span><span class="c"> </span><span class="c">an</span><span class="c"> </span><span class="c">asynchronous</span><span class="c"> </span>
<span class="l">3: </span>  <span class="c">//</span><span class="c"> </span><span class="c">sequence</span><span class="c"> </span><span class="c">in</span><span class="c"> </span><span class="c">chunks</span><span class="c"> </span><span class="c">of</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">specified</span><span class="c"> </span><span class="c">size</span>
<span class="l">4: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fasyst227', 59)" onmouseover="showTip(event, 'fasyst227', 59)" class="i">AsyncReadSeq</span> <span class="o">:</span> <span class="o">?</span><span class="i">bufferSize</span><span class="o">:</span><span onmouseout="hideTip(event, 'fasyst228', 60)" onmouseover="showTip(event, 'fasyst228', 60)" class="i">int</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst229', 61)" onmouseover="showTip(event, 'fasyst229', 61)" class="i">AsyncSeq</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fasyst230', 62)" onmouseover="showTip(event, 'fasyst230', 62)" class="i">byte</span> []<span class="o">&gt;</span>
<span class="l">5: </span>
<span class="l">6: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fasyst224', 63)" onmouseover="showTip(event, 'fasyst224', 63)" class="i">System</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst225', 64)" onmouseover="showTip(event, 'fasyst225', 64)" class="i">IO</span><span class="o">.</span><span onmouseout="hideTip(event, 'fasyst226', 65)" onmouseover="showTip(event, 'fasyst226', 65)" class="i">Stream</span> <span class="k">with</span>
<span class="l">7: </span>  <span class="c">//</span><span class="c"> </span><span class="c">Asynchronously</span><span class="c"> </span><span class="c">write</span><span class="c"> </span><span class="c">all</span><span class="c"> </span><span class="c">data</span><span class="c"> </span><span class="c">from</span><span class="c"> </span><span class="c">an</span><span class="c"> </span>
<span class="l">8: </span>  <span class="c">//</span><span class="c"> </span><span class="c">asynchronous</span><span class="c"> </span><span class="c">sequence</span><span class="c"> </span><span class="c">to</span><span class="c"> </span><span class="c">the</span><span class="c"> </span><span class="c">current</span><span class="c"> </span><span class="c">stream.</span>
<span class="l">9: </span>  <span class="k">member</span> <span onmouseout="hideTip(event, 'fasyst231', 66)" onmouseover="showTip(event, 'fasyst231', 66)" class="i">AsyncWriteSeq</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fasyst229', 67)" onmouseover="showTip(event, 'fasyst229', 67)" class="i">AsyncSeq</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fasyst230', 68)" onmouseover="showTip(event, 'fasyst230', 68)" class="i">byte</span> []<span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fasyst23', 69)" onmouseover="showTip(event, 'fasyst23', 69)" class="i">Async</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fasyst210', 70)" onmouseover="showTip(event, 'fasyst210', 70)" class="i">unit</span><span class="o">&gt;</span></pre>

<p>The <code>AsyncReadSeq</code> member creates an asynchronou sequence that reads
  the content of a stream on-demand. The <code>AsyncWriteSeq</code> member creates an asynchronous
  workflow that reads all buffers from the input asynchronous sequence and writes them 
  to the output stream. Together, the two operations behave exactly the same as 
  asynchronous workflow containing a loop.</p>

<p>Note that this is a different behavior than what we could implement using 
  <code>IObservable&lt;'T&gt;</code>. If the write operation takes longer than the read
  operation, the processing speed will be limited to the speed determined by the write
  operation. Reading more data than what can be actually written to the output would be
  unfortunate and we'd have to store it in some temporary buffer.</p>

<p>Another area where asynchronous sequences may fit quite nicely is the implementation
  of <em>pipeline processing</em>. In my <a href="http://tomasp.net/articles/parallel-extra-image-pipeline.aspx">earlier implementation</a> [<a href="#assqrf">1</a>] of pipeline processing
  in F#, I used a simple blocking queue implemented as an agent (see <code>BlockingQueueAgent</code>
  <a href="http://msdn.microsoft.com/en-us/library/hh297096.aspx">implementation on MSDN</a> [<a href="#assqrf">3</a>]). The queue is used between two processors and controls the process
  by blocking the producer (when the queue is full) or the consumer (when there are no values).
  This has some limitations - for example, there is no way to find out <a href="http://stackoverflow.com/questions/6995313/mailboxprocessor-tell-when-to-stop">when the pipeline 
  processing completes</a> [<a href="#assqrf">2</a>]. I believe that the same thing could be more elegantly implemented
  using asynchronous sequences, using some queueing combinator to connect the sequences.</p>

<h2>Summary</h2>
<p>In this article, we looked at <em>asynchronous sequences</em>, which is an abstraction that
  can be used for writing computations that generate multiple values asynchronously. Asynchronous
  sequences are based on standard F# asynchronous workflows and they work extremely well together.
  Asynchronous sequence can be constructed using a computation expression <code>asyncSeq { .. }</code>
  that can call asynchronous workflows. It can be also consumed using <code>for</code> loop inside
  asynchronous workflow.</p>

<p>The programming model behind asynchronous sequences is <em>asynchronous pull</em>. We can request
  the next element of the sequence and we eventually get a reply (which may be a value or <code>Nil</code>).
  This is different to the <em>push</em> model of <code>IObservable&lt;'T&gt;</code>, which 
  generates values regardless of the consumer's state. Asynchronous sequences provide a good way
  to represent asynchronous data sources that can be controlled by the consumer, for example, when the
  consumer isn't ready to handle more data. Examples include web crawlers or reading records from a file or 
  a database.</p>

<p>In this article, I demonstrated the computation builder for creating asynchronous sequences and
  some basic combinators for working with them. We've also seen a basic web crawler (and you can 
  find a more advanced version in the samples below). There are quite a few interesting topics that
  didn't fit in this article and I hope to cover them in the future. For example, <code>IObservable&lt;'T&gt;</code>
  can be converted to an asynchronous sequence in two ways (<code>AsyncSeq.ofObservable</code>
  and <code>AsyncSeq.ofObservableBuffered</code>), they can be cached (<code>AsyncSeq.cached</code>)
  and they can be nicely used in conjunction with agents. You can learn more by exploring the additional
  samples and by writing some snippets and sharing them on <a href="http://www.fssnip.net">fssnip.net</a>!</p>

<h2>Downloads &amp; References<a name="assqrf">&#160;</a></h2>
<ul>
  <li>Asynchronous sequences are implemented in <a href="https://github.com/tpetricek/FSharp.AsyncExtensions">FSharp.AsyncExtensions</a> on GitHub.</li>
  <li>The web crawler sample (with some extensions) can be found in <a href="https://github.com/tpetricek/FSharp.AsyncExtensions/blob/master/samples/Crawler.fsx">Crawler.fsx</a>.</li>
  <li>View samples on <a href="http://www.fssnip.net/7f">F# snippets</a> (and grab the <a href="http://www.fssnip.net/raw/7f">raw code</a> to post your snippets!)</li>
</ul>
<ul>
  <li>[1] <a href="http://tomasp.net/articles/parallel-extra-image-pipeline.aspx">F# Parallel Extras (I.): Image pipeline using agents</a> - TomasP.Net</li>
  <li>[2] <a href="http://stackoverflow.com/questions/6995313/mailboxprocessor-tell-when-to-stop">MailboxProcessor - Tell when to stop?</a> - StackOverflow.com</li>
  <li>[3] <a href="http://msdn.microsoft.com/en-us/library/hh297096.aspx">How to: Create a Blocking Queue Using Agents</a> - MSDN Library</li>
</ul>

<!-- HTML code for ToolTips -->
<div class="tip" id="fasyst11">Multiple items
<br />module AsyncSeq<br /><br />from FSharp.Control
<br /><br />--------------------<br />
<br />type AsyncSeq&lt;&#39;T&gt; = Async&lt;AsyncSeqInner&lt;&#39;T&gt;&gt;<br /><br />Full name: FSharp.Control.AsyncSeq&lt;_&gt;
<br /><br /><em>Asynchronous computation that produces either end of a sequence<br />&#160;(Nil) or the next value together with the rest of the sequence.</em><br /></div>
<div class="tip" id="fasyst12">Multiple items
<br />type Async&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Control.Async&lt;_&gt;
<br /><br />--------------------<br />
<br />type Async<br />with<br />&#160;&#160;static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; &#39;T) * (IAsyncResult -&gt; unit)<br />&#160;&#160;static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; Delegate)<br />&#160;&#160;static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />&#160;&#160;static member AwaitTask : task:Threading.Tasks.Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member AwaitWaitHandle : waitHandle:Threading.WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />&#160;&#160;static member CancelDefaultToken : unit -&gt; unit<br />&#160;&#160;static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;<br />&#160;&#160;static member FromBeginEnd : beginAction:(AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member FromBeginEnd : arg:&#39;Arg1 * beginAction:(&#39;Arg1 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * beginAction:(&#39;Arg1 * &#39;Arg2 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * arg3:&#39;Arg3 * beginAction:(&#39;Arg1 * &#39;Arg2 * &#39;Arg3 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member Ignore : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member OnCancel : interruption:(unit -&gt; unit) -&gt; Async&lt;IDisposable&gt;<br />&#160;&#160;static member Parallel : computations:seq&lt;Async&lt;&#39;T&gt;&gt; -&gt; Async&lt;&#39;T []&gt;<br />&#160;&#160;static member RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:Threading.CancellationToken -&gt; &#39;T<br />&#160;&#160;static member Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member Start : computation:Async&lt;unit&gt; * ?cancellationToken:Threading.CancellationToken -&gt; unit<br />&#160;&#160;static member StartAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:Threading.Tasks.TaskCreationOptions * ?cancellationToken:Threading.CancellationToken -&gt; Threading.Tasks.Task&lt;&#39;T&gt;<br />&#160;&#160;static member StartChild : computation:Async&lt;&#39;T&gt; * ?millisecondsTimeout:int -&gt; Async&lt;Async&lt;&#39;T&gt;&gt;<br />&#160;&#160;static member StartChildAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:Threading.Tasks.TaskCreationOptions -&gt; Async&lt;Threading.Tasks.Task&lt;&#39;T&gt;&gt;<br />&#160;&#160;static member StartImmediate : computation:Async&lt;unit&gt; * ?cancellationToken:Threading.CancellationToken -&gt; unit<br />&#160;&#160;static member StartWithContinuations : computation:Async&lt;&#39;T&gt; * continuation:(&#39;T -&gt; unit) * exceptionContinuation:(exn -&gt; unit) * cancellationContinuation:(OperationCanceledException -&gt; unit) * ?cancellationToken:Threading.CancellationToken -&gt; unit<br />&#160;&#160;static member SwitchToContext : syncContext:Threading.SynchronizationContext -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member SwitchToNewThread : unit -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member SwitchToThreadPool : unit -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member TryCancelled : computation:Async&lt;&#39;T&gt; * compensation:(OperationCanceledException -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member CancellationToken : Async&lt;Threading.CancellationToken&gt;<br />&#160;&#160;static member DefaultCancellationToken : Threading.CancellationToken<br />end<br /><br />Full name: Microsoft.FSharp.Control.Async<br /></div>
<div class="tip" id="fasyst13">type AsyncSeqInner&lt;&#39;T&gt; =<br />&#160;&#160;| Nil<br />&#160;&#160;| Cons of &#39;T * AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharp.Control.AsyncSeqInner&lt;_&gt;<br /></div>
<div class="tip" id="fasyst14">union case AsyncSeqInner.Nil: AsyncSeqInner&lt;&#39;T&gt;<br /></div>
<div class="tip" id="fasyst15">union case AsyncSeqInner.Cons: &#39;T * AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeqInner&lt;&#39;T&gt;<br /></div>
<div class="tip" id="fasyst16">val oneTwo : AsyncSeq&lt;int&gt;<br /><br />Full name: FSharp.Samples.oneTwo<br /></div>
<div class="tip" id="fasyst17">val asyncSeq : AsyncSeq.AsyncSeqBuilder<br /><br />Full name: FSharp.Control.AsyncSeqExtensions.asyncSeq<br /></div>
<div class="tip" id="fasyst18">static member Async.Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;<br /></div>
<div class="tip" id="fasyst19">val urls : string list<br /><br />Full name: FSharp.Samples.urls<br /><br />&#160;&#160;type: string list<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: IComparable&lt;List&lt;string&gt;&gt;<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: Collections.IStructuralComparable<br />&#160;&#160;implements: Collections.Generic.IEnumerable&lt;string&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br /></div>
<div class="tip" id="fasyst110">val pages : AsyncSeq&lt;string * int&gt;<br /><br />Full name: FSharp.Samples.pages<br /></div>
<div class="tip" id="fasyst111">val wc : WebClient<br /><br />&#160;&#160;type: WebClient<br />&#160;&#160;implements: ComponentModel.IComponent<br />&#160;&#160;implements: IDisposable<br />&#160;&#160;inherits: ComponentModel.Component<br />&#160;&#160;inherits: MarshalByRefObject<br /></div>
<div class="tip" id="fasyst112">type WebClient =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;inherit System.ComponentModel.Component<br />&#160;&#160;&#160;&#160;new : unit -&gt; System.Net.WebClient<br />&#160;&#160;&#160;&#160;member BaseAddress : string with get, set<br />&#160;&#160;&#160;&#160;member CachePolicy : System.Net.Cache.RequestCachePolicy with get, set<br />&#160;&#160;&#160;&#160;member CancelAsync : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Credentials : System.Net.ICredentials with get, set<br />&#160;&#160;&#160;&#160;member DownloadData : string -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member DownloadData : System.Uri -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member DownloadDataAsync : System.Uri -&gt; unit<br />&#160;&#160;&#160;&#160;member DownloadDataAsync : System.Uri * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member DownloadFile : string * string -&gt; unit<br />&#160;&#160;&#160;&#160;member DownloadFile : System.Uri * string -&gt; unit<br />&#160;&#160;&#160;&#160;member DownloadFileAsync : System.Uri * string -&gt; unit<br />&#160;&#160;&#160;&#160;member DownloadFileAsync : System.Uri * string * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member DownloadString : string -&gt; string<br />&#160;&#160;&#160;&#160;member DownloadString : System.Uri -&gt; string<br />&#160;&#160;&#160;&#160;member DownloadStringAsync : System.Uri -&gt; unit<br />&#160;&#160;&#160;&#160;member DownloadStringAsync : System.Uri * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member Encoding : System.Text.Encoding with get, set<br />&#160;&#160;&#160;&#160;member Headers : System.Net.WebHeaderCollection with get, set<br />&#160;&#160;&#160;&#160;member IsBusy : bool<br />&#160;&#160;&#160;&#160;member OpenRead : string -&gt; System.IO.Stream<br />&#160;&#160;&#160;&#160;member OpenRead : System.Uri -&gt; System.IO.Stream<br />&#160;&#160;&#160;&#160;member OpenReadAsync : System.Uri -&gt; unit<br />&#160;&#160;&#160;&#160;member OpenReadAsync : System.Uri * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member OpenWrite : string -&gt; System.IO.Stream<br />&#160;&#160;&#160;&#160;member OpenWrite : System.Uri -&gt; System.IO.Stream<br />&#160;&#160;&#160;&#160;member OpenWrite : string * string -&gt; System.IO.Stream<br />&#160;&#160;&#160;&#160;member OpenWrite : System.Uri * string -&gt; System.IO.Stream<br />&#160;&#160;&#160;&#160;member OpenWriteAsync : System.Uri -&gt; unit<br />&#160;&#160;&#160;&#160;member OpenWriteAsync : System.Uri * string -&gt; unit<br />&#160;&#160;&#160;&#160;member OpenWriteAsync : System.Uri * string * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member Proxy : System.Net.IWebProxy with get, set<br />&#160;&#160;&#160;&#160;member QueryString : System.Collections.Specialized.NameValueCollection with get, set<br />&#160;&#160;&#160;&#160;member ResponseHeaders : System.Net.WebHeaderCollection<br />&#160;&#160;&#160;&#160;member UploadData : string * System.Byte [] -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member UploadData : System.Uri * System.Byte [] -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member UploadData : string * string * System.Byte [] -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member UploadData : System.Uri * string * System.Byte [] -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member UploadDataAsync : System.Uri * System.Byte [] -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadDataAsync : System.Uri * string * System.Byte [] -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadDataAsync : System.Uri * string * System.Byte [] * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadFile : string * string -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member UploadFile : System.Uri * string -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member UploadFile : string * string * string -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member UploadFile : System.Uri * string * string -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member UploadFileAsync : System.Uri * string -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadFileAsync : System.Uri * string * string -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadFileAsync : System.Uri * string * string * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadString : string * string -&gt; string<br />&#160;&#160;&#160;&#160;member UploadString : System.Uri * string -&gt; string<br />&#160;&#160;&#160;&#160;member UploadString : string * string * string -&gt; string<br />&#160;&#160;&#160;&#160;member UploadString : System.Uri * string * string -&gt; string<br />&#160;&#160;&#160;&#160;member UploadStringAsync : System.Uri * string -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadStringAsync : System.Uri * string * string -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadStringAsync : System.Uri * string * string * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadValues : string * System.Collections.Specialized.NameValueCollection -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member UploadValues : System.Uri * System.Collections.Specialized.NameValueCollection -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member UploadValues : string * string * System.Collections.Specialized.NameValueCollection -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member UploadValues : System.Uri * string * System.Collections.Specialized.NameValueCollection -&gt; System.Byte []<br />&#160;&#160;&#160;&#160;member UploadValuesAsync : System.Uri * System.Collections.Specialized.NameValueCollection -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadValuesAsync : System.Uri * string * System.Collections.Specialized.NameValueCollection -&gt; unit<br />&#160;&#160;&#160;&#160;member UploadValuesAsync : System.Uri * string * System.Collections.Specialized.NameValueCollection * obj -&gt; unit<br />&#160;&#160;&#160;&#160;member UseDefaultCredentials : bool with get, set<br />&#160;&#160;end<br /><br />Full name: System.Net.WebClient<br /><br />&#160;&#160;type: WebClient<br />&#160;&#160;implements: ComponentModel.IComponent<br />&#160;&#160;implements: IDisposable<br />&#160;&#160;inherits: ComponentModel.Component<br />&#160;&#160;inherits: MarshalByRefObject<br /></div>
<div class="tip" id="fasyst113">val url : string<br /><br />&#160;&#160;type: string<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;string&gt;<br />&#160;&#160;implements: seq&lt;char&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;implements: IEquatable&lt;string&gt;<br /></div>
<div class="tip" id="fasyst114">val html : string<br /><br />&#160;&#160;type: string<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;string&gt;<br />&#160;&#160;implements: seq&lt;char&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;implements: IEquatable&lt;string&gt;<br /></div>
<div class="tip" id="fasyst115">member WebClient.AsyncDownloadString : address:Uri -&gt; Async&lt;string&gt;<br /></div>
<div class="tip" id="fasyst116">type Uri =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;new : string -&gt; System.Uri<br />&#160;&#160;&#160;&#160;new : string * bool -&gt; System.Uri<br />&#160;&#160;&#160;&#160;new : string * System.UriKind -&gt; System.Uri<br />&#160;&#160;&#160;&#160;new : System.Uri * string -&gt; System.Uri<br />&#160;&#160;&#160;&#160;new : System.Uri * string * bool -&gt; System.Uri<br />&#160;&#160;&#160;&#160;new : System.Uri * System.Uri -&gt; System.Uri<br />&#160;&#160;&#160;&#160;member AbsolutePath : string<br />&#160;&#160;&#160;&#160;member AbsoluteUri : string<br />&#160;&#160;&#160;&#160;member Authority : string<br />&#160;&#160;&#160;&#160;member DnsSafeHost : string<br />&#160;&#160;&#160;&#160;member Equals : obj -&gt; bool<br />&#160;&#160;&#160;&#160;member Fragment : string<br />&#160;&#160;&#160;&#160;member GetComponents : System.UriComponents * System.UriFormat -&gt; string<br />&#160;&#160;&#160;&#160;member GetHashCode : unit -&gt; int<br />&#160;&#160;&#160;&#160;member GetLeftPart : System.UriPartial -&gt; string<br />&#160;&#160;&#160;&#160;member Host : string<br />&#160;&#160;&#160;&#160;member HostNameType : System.UriHostNameType<br />&#160;&#160;&#160;&#160;member IsAbsoluteUri : bool<br />&#160;&#160;&#160;&#160;member IsBaseOf : System.Uri -&gt; bool<br />&#160;&#160;&#160;&#160;member IsDefaultPort : bool<br />&#160;&#160;&#160;&#160;member IsFile : bool<br />&#160;&#160;&#160;&#160;member IsLoopback : bool<br />&#160;&#160;&#160;&#160;member IsUnc : bool<br />&#160;&#160;&#160;&#160;member IsWellFormedOriginalString : unit -&gt; bool<br />&#160;&#160;&#160;&#160;member LocalPath : string<br />&#160;&#160;&#160;&#160;member MakeRelative : System.Uri -&gt; string<br />&#160;&#160;&#160;&#160;member MakeRelativeUri : System.Uri -&gt; System.Uri<br />&#160;&#160;&#160;&#160;member OriginalString : string<br />&#160;&#160;&#160;&#160;member PathAndQuery : string<br />&#160;&#160;&#160;&#160;member Port : int<br />&#160;&#160;&#160;&#160;member Query : string<br />&#160;&#160;&#160;&#160;member Scheme : string<br />&#160;&#160;&#160;&#160;member Segments : string []<br />&#160;&#160;&#160;&#160;member ToString : unit -&gt; string<br />&#160;&#160;&#160;&#160;member UserEscaped : bool<br />&#160;&#160;&#160;&#160;member UserInfo : string<br />&#160;&#160;&#160;&#160;static val UriSchemeFile : string<br />&#160;&#160;&#160;&#160;static val UriSchemeFtp : string<br />&#160;&#160;&#160;&#160;static val UriSchemeGopher : string<br />&#160;&#160;&#160;&#160;static val UriSchemeHttp : string<br />&#160;&#160;&#160;&#160;static val UriSchemeHttps : string<br />&#160;&#160;&#160;&#160;static val UriSchemeMailto : string<br />&#160;&#160;&#160;&#160;static val UriSchemeNews : string<br />&#160;&#160;&#160;&#160;static val UriSchemeNntp : string<br />&#160;&#160;&#160;&#160;static val UriSchemeNetTcp : string<br />&#160;&#160;&#160;&#160;static val UriSchemeNetPipe : string<br />&#160;&#160;&#160;&#160;static val SchemeDelimiter : string<br />&#160;&#160;&#160;&#160;static member CheckHostName : string -&gt; System.UriHostNameType<br />&#160;&#160;&#160;&#160;static member CheckSchemeName : string -&gt; bool<br />&#160;&#160;&#160;&#160;static member Compare : System.Uri * System.Uri * System.UriComponents * System.UriFormat * System.StringComparison -&gt; int<br />&#160;&#160;&#160;&#160;static member EscapeDataString : string -&gt; string<br />&#160;&#160;&#160;&#160;static member EscapeUriString : string -&gt; string<br />&#160;&#160;&#160;&#160;static member FromHex : char -&gt; int<br />&#160;&#160;&#160;&#160;static member HexEscape : char -&gt; string<br />&#160;&#160;&#160;&#160;static member HexUnescape : string * int -&gt; char<br />&#160;&#160;&#160;&#160;static member IsHexDigit : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsHexEncoding : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsWellFormedUriString : string * System.UriKind -&gt; bool<br />&#160;&#160;&#160;&#160;static member TryCreate : string * System.UriKind * System.Uri -&gt; bool<br />&#160;&#160;&#160;&#160;static member TryCreate : System.Uri * string * System.Uri -&gt; bool<br />&#160;&#160;&#160;&#160;static member TryCreate : System.Uri * System.Uri * System.Uri -&gt; bool<br />&#160;&#160;&#160;&#160;static member UnescapeDataString : string -&gt; string<br />&#160;&#160;end<br /><br />Full name: System.Uri<br /><br />&#160;&#160;type: Uri<br />&#160;&#160;implements: Runtime.Serialization.ISerializable<br /></div>
<div class="tip" id="fasyst117">val async : AsyncBuilder<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.async<br /></div>
<div class="tip" id="fasyst118">val length : int<br /><br />&#160;&#160;type: int<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: IFormattable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;int&gt;<br />&#160;&#160;implements: IEquatable&lt;int&gt;<br />&#160;&#160;inherits: ValueType<br /></div>
<div class="tip" id="fasyst119">val printfn : Printf.TextWriterFormat&lt;&#39;T&gt; -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.printfn<br /></div>
<div class="tip" id="fasyst120">static member Async.Start : computation:Async&lt;unit&gt; * ?cancellationToken:Threading.CancellationToken -&gt; unit<br /></div>
<div class="tip" id="fasyst121">val printPages : Async&lt;unit&gt;<br /><br />Full name: FSharp.Samples.printPages<br /></div>
<div class="tip" id="fasyst122">Multiple items
<br />module AsyncSeq<br /><br />from FSharp.Control
<br /><br />--------------------<br />
<br />type AsyncSeq&lt;&#39;T&gt; = Async&lt;AsyncSeqInner&lt;&#39;T&gt;&gt;<br /><br />Full name: FSharp.Control.AsyncSeq&lt;_&gt;<br /></div>
<div class="tip" id="fasyst123">val filter : (&#39;T -&gt; bool) -&gt; AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.filter<br /></div>
<div class="tip" id="fasyst124">val len : int<br /><br />&#160;&#160;type: int<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: IFormattable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;int&gt;<br />&#160;&#160;implements: IEquatable&lt;int&gt;<br />&#160;&#160;inherits: ValueType<br /></div>
<div class="tip" id="fasyst125">val map : (&#39;T -&gt; &#39;a) -&gt; AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;a&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.map<br /></div>
<div class="tip" id="fasyst126">val fst : (&#39;T1 * &#39;T2) -&gt; &#39;T1<br /><br />Full name: Microsoft.FSharp.Core.Operators.fst<br /></div>
<div class="tip" id="fasyst127">val iter : (&#39;T -&gt; unit) -&gt; AsyncSeq&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.iter<br /></div>
<div class="tip" id="fasyst128">val filter : (&#39;T -&gt; bool) -&gt; AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharp.Samples.filter
<br /><br /><em>Return elements for which the predicate returns true</em><br /></div>
<div class="tip" id="fasyst129">val f : (&#39;T -&gt; bool)<br /></div>
<div class="tip" id="fasyst130">val input : AsyncSeq&lt;&#39;T&gt;<br /></div>
<div class="tip" id="fasyst131">val v : &#39;T<br /></div>
<div class="tip" id="fasyst132">val filterAsync : (&#39;T -&gt; Async&lt;bool&gt;) -&gt; AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharp.Samples.filterAsync
<br /><br /><em>Return elements for which the asynchronous predicate returns true</em><br /></div>
<div class="tip" id="fasyst133">val f : (&#39;T -&gt; Async&lt;bool&gt;)<br /></div>
<div class="tip" id="fasyst134">val b : bool<br /><br />&#160;&#160;type: bool<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;bool&gt;<br />&#160;&#160;implements: IEquatable&lt;bool&gt;<br />&#160;&#160;inherits: ValueType<br /></div>
<div class="tip" id="fasyst135">val randomCrawl : string -&gt; AsyncSeq&lt;string * string&gt;<br /><br />Full name: FSharp.Crawler.randomCrawl
<br /><br /><em>Crawl the internet starting from the specified page.<br />&#160;From each page follow the first not-yet-visited page.</em><br /></div>
<div class="tip" id="fasyst136">val visited : Collections.Generic.HashSet&lt;string&gt;<br /><br />&#160;&#160;type: Collections.Generic.HashSet&lt;string&gt;<br />&#160;&#160;implements: Runtime.Serialization.ISerializable<br />&#160;&#160;implements: Runtime.Serialization.IDeserializationCallback<br />&#160;&#160;implements: Collections.Generic.ISet&lt;string&gt;<br />&#160;&#160;implements: Collections.Generic.ICollection&lt;string&gt;<br />&#160;&#160;implements: seq&lt;string&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br /></div>
<div class="tip" id="fasyst137">namespace System<br /></div>
<div class="tip" id="fasyst138">namespace System.Collections<br /></div>
<div class="tip" id="fasyst139">namespace System.Collections.Generic<br /></div>
<div class="tip" id="fasyst140">type HashSet&lt;&#39;T&gt; =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;new : unit -&gt; System.Collections.Generic.HashSet&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;new : System.Collections.Generic.IEqualityComparer&lt;&#39;T&gt; -&gt; System.Collections.Generic.HashSet&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;new : System.Collections.Generic.IEnumerable&lt;&#39;T&gt; -&gt; System.Collections.Generic.HashSet&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;new : System.Collections.Generic.IEnumerable&lt;&#39;T&gt; * System.Collections.Generic.IEqualityComparer&lt;&#39;T&gt; -&gt; System.Collections.Generic.HashSet&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member Add : &#39;T -&gt; bool<br />&#160;&#160;&#160;&#160;member Clear : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Comparer : System.Collections.Generic.IEqualityComparer&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member Contains : &#39;T -&gt; bool<br />&#160;&#160;&#160;&#160;member CopyTo : &#39;T [] -&gt; unit<br />&#160;&#160;&#160;&#160;member CopyTo : &#39;T [] * int -&gt; unit<br />&#160;&#160;&#160;&#160;member CopyTo : &#39;T [] * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;member Count : int<br />&#160;&#160;&#160;&#160;member ExceptWith : System.Collections.Generic.IEnumerable&lt;&#39;T&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;member GetEnumerator : unit -&gt; Enumerator&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit<br />&#160;&#160;&#160;&#160;member IntersectWith : System.Collections.Generic.IEnumerable&lt;&#39;T&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;member IsProperSubsetOf : System.Collections.Generic.IEnumerable&lt;&#39;T&gt; -&gt; bool<br />&#160;&#160;&#160;&#160;member IsProperSupersetOf : System.Collections.Generic.IEnumerable&lt;&#39;T&gt; -&gt; bool<br />&#160;&#160;&#160;&#160;member IsSubsetOf : System.Collections.Generic.IEnumerable&lt;&#39;T&gt; -&gt; bool<br />&#160;&#160;&#160;&#160;member IsSupersetOf : System.Collections.Generic.IEnumerable&lt;&#39;T&gt; -&gt; bool<br />&#160;&#160;&#160;&#160;member OnDeserialization : obj -&gt; unit<br />&#160;&#160;&#160;&#160;member Overlaps : System.Collections.Generic.IEnumerable&lt;&#39;T&gt; -&gt; bool<br />&#160;&#160;&#160;&#160;member Remove : &#39;T -&gt; bool<br />&#160;&#160;&#160;&#160;member RemoveWhere : System.Predicate&lt;&#39;T&gt; -&gt; int<br />&#160;&#160;&#160;&#160;member SetEquals : System.Collections.Generic.IEnumerable&lt;&#39;T&gt; -&gt; bool<br />&#160;&#160;&#160;&#160;member SymmetricExceptWith : System.Collections.Generic.IEnumerable&lt;&#39;T&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;member TrimExcess : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member UnionWith : System.Collections.Generic.IEnumerable&lt;&#39;T&gt; -&gt; unit<br />&#160;&#160;&#160;&#160;static member CreateSetComparer : unit -&gt; System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;&#39;T&gt;&gt;<br />&#160;&#160;&#160;&#160;type Enumerator =<br />&#160;&#160;&#160;&#160;&#160;&#160;struct<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;member Current : &#39;T<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;member Dispose : unit -&gt; unit<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;member MoveNext : unit -&gt; bool<br />&#160;&#160;&#160;&#160;&#160;&#160;end<br />&#160;&#160;end<br /><br />Full name: System.Collections.Generic.HashSet&lt;_&gt;<br /><br />&#160;&#160;type: Collections.Generic.HashSet&lt;&#39;T&gt;<br />&#160;&#160;implements: Runtime.Serialization.ISerializable<br />&#160;&#160;implements: Runtime.Serialization.IDeserializationCallback<br />&#160;&#160;implements: Collections.Generic.ISet&lt;&#39;T&gt;<br />&#160;&#160;implements: Collections.Generic.ICollection&lt;&#39;T&gt;<br />&#160;&#160;implements: seq&lt;&#39;T&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br /></div>
<div class="tip" id="fasyst141">val loop : (string -&gt; AsyncSeq&lt;string * string&gt;)<br /></div>
<div class="tip" id="fasyst142">Collections.Generic.HashSet.Add(item: string) : bool<br /></div>
<div class="tip" id="fasyst143">val doc : HtmlDocument option<br /><br />&#160;&#160;type: HtmlDocument option<br />&#160;&#160;implements: Collections.IStructuralEquatable<br />&#160;&#160;implements: IComparable&lt;Option&lt;HtmlDocument&gt;&gt;<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: Collections.IStructuralComparable<br /></div>
<div class="tip" id="fasyst144">val downloadDocument : string -&gt; Async&lt;HtmlDocument option&gt;<br /><br />Full name: FSharp.Crawler.downloadDocument
<br /><br /><em>Asynchronously download the document and parse the HTML</em><br /></div>
<div class="tip" id="fasyst145">union case Option.Some: &#39;T -&gt; Option&lt;&#39;T&gt;<br /></div>
<div class="tip" id="fasyst146">val doc : HtmlDocument<br /><br />&#160;&#160;type: HtmlDocument<br />&#160;&#160;implements: Xml.XPath.IXPathNavigable<br /></div>
<div class="tip" id="fasyst147">val getTitle : HtmlDocument -&gt; string<br /><br />Full name: FSharp.Crawler.getTitle
<br /><br /><em>Extract the &lt;title&gt; of the web page</em><br /></div>
<div class="tip" id="fasyst148">val link : string<br /><br />&#160;&#160;type: string<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;string&gt;<br />&#160;&#160;implements: seq&lt;char&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;implements: IEquatable&lt;string&gt;<br /></div>
<div class="tip" id="fasyst149">val extractLinks : HtmlDocument -&gt; string list<br /><br />Full name: FSharp.Crawler.extractLinks
<br /><br /><em>Extract all links from the document that start with &quot;http://&quot;</em><br /></div>
<div class="tip" id="fasyst150">val title : string<br /><br />&#160;&#160;type: string<br />&#160;&#160;implements: IComparable<br />&#160;&#160;implements: ICloneable<br />&#160;&#160;implements: IConvertible<br />&#160;&#160;implements: IComparable&lt;string&gt;<br />&#160;&#160;implements: seq&lt;char&gt;<br />&#160;&#160;implements: Collections.IEnumerable<br />&#160;&#160;implements: IEquatable&lt;string&gt;<br /></div>
<div class="tip" id="fasyst151">val not : bool -&gt; bool<br /><br />Full name: Microsoft.FSharp.Core.Operators.not<br /></div>
<div class="tip" id="fasyst152">val snd : (&#39;T1 * &#39;T2) -&gt; &#39;T2<br /><br />Full name: Microsoft.FSharp.Core.Operators.snd<br /></div>
<div class="tip" id="fasyst153">val take : int -&gt; AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.take<br /></div>



<!-- HTML code for ToolTips -->
<div class="tip" id="fasyst21">type AsyncSeqBuilder =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;member Bind : Async&lt;&#39;T&gt; * (&#39;T -&gt; AsyncSeq&lt;&#39;U&gt;) -&gt; AsyncSeq&lt;&#39;U&gt;<br />&#160;&#160;&#160;&#160;member Combine : AsyncSeq&lt;&#39;T&gt; * AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member For : AsyncSeq&lt;&#39;T&gt; * (&#39;T -&gt; AsyncSeq&lt;&#39;TResult&gt;) -&gt; AsyncSeq&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;&#160;member For : seq&lt;&#39;T&gt; * (&#39;T -&gt; AsyncSeq&lt;&#39;TResult&gt;) -&gt; AsyncSeq&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;&#160;member Yield : &#39;T -&gt; AsyncSeq&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member Zero : unit -&gt; AsyncSeq&lt;&#39;T&gt;<br />&#160;&#160;end<br /><br />Full name: FSharp.Control.AsyncSeq.AsyncSeqBuilder<br /></div>
<div class="tip" id="fasyst22">member AsyncSeqBuilder.Bind : Async&lt;&#39;T&gt; * (&#39;T -&gt; AsyncSeq&lt;&#39;U&gt;) -&gt; AsyncSeq&lt;&#39;U&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.AsyncSeqBuilder.Bind<br /></div>
<div class="tip" id="fasyst23">Multiple items
<br />type Async&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Control.Async&lt;_&gt;
<br /><br />--------------------<br />
<br />type Async<br />with<br />&#160;&#160;static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * System.AsyncCallback * obj -&gt; System.IAsyncResult) * (System.IAsyncResult -&gt; &#39;T) * (System.IAsyncResult -&gt; unit)<br />&#160;&#160;static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; System.Delegate)<br />&#160;&#160;static member AwaitIAsyncResult : iar:System.IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />&#160;&#160;static member AwaitTask : task:System.Threading.Tasks.Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member AwaitWaitHandle : waitHandle:System.Threading.WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />&#160;&#160;static member CancelDefaultToken : unit -&gt; unit<br />&#160;&#160;static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;<br />&#160;&#160;static member FromBeginEnd : beginAction:(System.AsyncCallback * obj -&gt; System.IAsyncResult) * endAction:(System.IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member FromBeginEnd : arg:&#39;Arg1 * beginAction:(&#39;Arg1 * System.AsyncCallback * obj -&gt; System.IAsyncResult) * endAction:(System.IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * beginAction:(&#39;Arg1 * &#39;Arg2 * System.AsyncCallback * obj -&gt; System.IAsyncResult) * endAction:(System.IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * arg3:&#39;Arg3 * beginAction:(&#39;Arg1 * &#39;Arg2 * &#39;Arg3 * System.AsyncCallback * obj -&gt; System.IAsyncResult) * endAction:(System.IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (System.OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member Ignore : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member OnCancel : interruption:(unit -&gt; unit) -&gt; Async&lt;System.IDisposable&gt;<br />&#160;&#160;static member Parallel : computations:seq&lt;Async&lt;&#39;T&gt;&gt; -&gt; Async&lt;&#39;T []&gt;<br />&#160;&#160;static member RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:System.Threading.CancellationToken -&gt; &#39;T<br />&#160;&#160;static member Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member Start : computation:Async&lt;unit&gt; * ?cancellationToken:System.Threading.CancellationToken -&gt; unit<br />&#160;&#160;static member StartAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:System.Threading.Tasks.TaskCreationOptions * ?cancellationToken:System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;&#39;T&gt;<br />&#160;&#160;static member StartChild : computation:Async&lt;&#39;T&gt; * ?millisecondsTimeout:int -&gt; Async&lt;Async&lt;&#39;T&gt;&gt;<br />&#160;&#160;static member StartChildAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:System.Threading.Tasks.TaskCreationOptions -&gt; Async&lt;System.Threading.Tasks.Task&lt;&#39;T&gt;&gt;<br />&#160;&#160;static member StartImmediate : computation:Async&lt;unit&gt; * ?cancellationToken:System.Threading.CancellationToken -&gt; unit<br />&#160;&#160;static member StartWithContinuations : computation:Async&lt;&#39;T&gt; * continuation:(&#39;T -&gt; unit) * exceptionContinuation:(exn -&gt; unit) * cancellationContinuation:(System.OperationCanceledException -&gt; unit) * ?cancellationToken:System.Threading.CancellationToken -&gt; unit<br />&#160;&#160;static member SwitchToContext : syncContext:System.Threading.SynchronizationContext -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member SwitchToNewThread : unit -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member SwitchToThreadPool : unit -&gt; Async&lt;unit&gt;<br />&#160;&#160;static member TryCancelled : computation:Async&lt;&#39;T&gt; * compensation:(System.OperationCanceledException -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;static member CancellationToken : Async&lt;System.Threading.CancellationToken&gt;<br />&#160;&#160;static member DefaultCancellationToken : System.Threading.CancellationToken<br />end<br /><br />Full name: Microsoft.FSharp.Control.Async<br /></div>
<div class="tip" id="fasyst24">type AsyncSeq&lt;&#39;T&gt; = Async&lt;AsyncSeqInner&lt;&#39;T&gt;&gt;<br /><br />Full name: FSharp.Control.AsyncSeq&lt;_&gt;<br /></div>
<div class="tip" id="fasyst25">member AsyncSeqBuilder.For : AsyncSeq&lt;&#39;T&gt; * (&#39;T -&gt; AsyncSeq&lt;&#39;TResult&gt;) -&gt; AsyncSeq&lt;&#39;TResult&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.AsyncSeqBuilder.For<br /></div>
<div class="tip" id="fasyst26">member AsyncSeqBuilder.For : seq&lt;&#39;T&gt; * (&#39;T -&gt; AsyncSeq&lt;&#39;TResult&gt;) -&gt; AsyncSeq&lt;&#39;TResult&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.AsyncSeqBuilder.For<br /></div>
<div class="tip" id="fasyst27">Multiple items
<br />val seq : seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Core.Operators.seq
<br /><br />--------------------<br />
<br />type seq&lt;&#39;T&gt; = System.Collections.Generic.IEnumerable&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.seq&lt;_&gt;<br /><br />&#160;&#160;type: seq&lt;&#39;T&gt;<br />&#160;&#160;inherits: System.Collections.IEnumerable<br /></div>
<div class="tip" id="fasyst28">member AsyncSeqBuilder.Yield : &#39;T -&gt; AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.AsyncSeqBuilder.Yield<br /></div>
<div class="tip" id="fasyst29">member AsyncSeqBuilder.Zero : unit -&gt; AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.AsyncSeqBuilder.Zero<br /></div>
<div class="tip" id="fasyst210">type unit = Unit<br /><br />Full name: Microsoft.FSharp.Core.unit<br /><br />&#160;&#160;type: unit<br />&#160;&#160;implements: System.IComparable<br /></div>
<div class="tip" id="fasyst211">member AsyncSeqBuilder.Combine : AsyncSeq&lt;&#39;T&gt; * AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.AsyncSeqBuilder.Combine<br /></div>
<div class="tip" id="fasyst212">namespace Microsoft<br /></div>
<div class="tip" id="fasyst213">namespace Microsoft.FSharp<br /></div>
<div class="tip" id="fasyst214">namespace Microsoft.FSharp.Control<br /></div>
<div class="tip" id="fasyst215">type AsyncBuilder =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;private new : unit -&gt; AsyncBuilder<br />&#160;&#160;&#160;&#160;member Bind : computation:Async&lt;&#39;T&gt; * binder:(&#39;T -&gt; Async&lt;&#39;U&gt;) -&gt; Async&lt;&#39;U&gt;<br />&#160;&#160;&#160;&#160;member Combine : computation1:Async&lt;unit&gt; * computation2:Async&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member Delay : generator:(unit -&gt; Async&lt;&#39;T&gt;) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member For : sequence:seq&lt;&#39;T&gt; * body:(&#39;T -&gt; Async&lt;unit&gt;) -&gt; Async&lt;unit&gt;<br />&#160;&#160;&#160;&#160;member Return : value:&#39;T -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member ReturnFrom : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member TryFinally : computation:Async&lt;&#39;T&gt; * compensation:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member TryWith : computation:Async&lt;&#39;T&gt; * catchHandler:(exn -&gt; Async&lt;&#39;T&gt;) -&gt; Async&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member Using : resource:&#39;T * binder:(&#39;T -&gt; Async&lt;&#39;U&gt;) -&gt; Async&lt;&#39;U&gt; (requires &#39;T :&gt; System.IDisposable)<br />&#160;&#160;&#160;&#160;member While : guard:(unit -&gt; bool) * computation:Async&lt;unit&gt; -&gt; Async&lt;unit&gt;<br />&#160;&#160;&#160;&#160;member Zero : unit -&gt; Async&lt;unit&gt;<br />&#160;&#160;end<br /><br />Full name: Microsoft.FSharp.Control.AsyncBuilder<br /></div>
<div class="tip" id="fasyst216">member AsyncBuilder.For : AsyncSeq&lt;&#39;T&gt; * (&#39;T -&gt; Async&lt;unit&gt;) -&gt; Async&lt;unit&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.For<br /></div>
<div class="tip" id="fasyst217">val foldAsync : (&#39;S -&gt; &#39;T -&gt; Async&lt;&#39;S&gt;) -&gt; &#39;S -&gt; AsyncSeq&lt;&#39;T&gt; -&gt; Async&lt;&#39;S&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.foldAsync<br /></div>
<div class="tip" id="fasyst218">val scanAsync : (&#39;S -&gt; &#39;T -&gt; Async&lt;&#39;S&gt;) -&gt; &#39;S -&gt; AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;S&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.scanAsync<br /></div>
<div class="tip" id="fasyst219">val fold : (&#39;S -&gt; &#39;T -&gt; &#39;S) -&gt; &#39;S -&gt; AsyncSeq&lt;&#39;T&gt; -&gt; Async&lt;&#39;S&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.fold<br /></div>
<div class="tip" id="fasyst220">val scan : (&#39;S -&gt; &#39;T -&gt; &#39;S) -&gt; &#39;S -&gt; AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;S&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.scan<br /></div>
<div class="tip" id="fasyst221">val takeWhileAsync : (&#39;T -&gt; Async&lt;bool&gt;) -&gt; AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.takeWhileAsync<br /></div>
<div class="tip" id="fasyst222">type bool = System.Boolean<br /><br />Full name: Microsoft.FSharp.Core.bool<br /><br />&#160;&#160;type: bool<br />&#160;&#160;implements: System.IComparable<br />&#160;&#160;implements: System.IConvertible<br />&#160;&#160;implements: System.IComparable&lt;bool&gt;<br />&#160;&#160;implements: System.IEquatable&lt;bool&gt;<br />&#160;&#160;inherits: System.ValueType<br /></div>
<div class="tip" id="fasyst223">val takeWhile : (&#39;T -&gt; bool) -&gt; AsyncSeq&lt;&#39;T&gt; -&gt; AsyncSeq&lt;&#39;T&gt;<br /><br />Full name: FSharp.Control.AsyncSeq.takeWhile<br /></div>
<div class="tip" id="fasyst224">namespace System<br /></div>
<div class="tip" id="fasyst225">namespace System.IO<br /></div>
<div class="tip" id="fasyst226">type Stream =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;inherit System.MarshalByRefObject<br />&#160;&#160;&#160;&#160;member BeginRead : System.Byte [] * int * int * System.AsyncCallback * obj -&gt; System.IAsyncResult<br />&#160;&#160;&#160;&#160;member BeginWrite : System.Byte [] * int * int * System.AsyncCallback * obj -&gt; System.IAsyncResult<br />&#160;&#160;&#160;&#160;member CanRead : bool<br />&#160;&#160;&#160;&#160;member CanSeek : bool<br />&#160;&#160;&#160;&#160;member CanTimeout : bool<br />&#160;&#160;&#160;&#160;member CanWrite : bool<br />&#160;&#160;&#160;&#160;member Close : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member CopyTo : System.IO.Stream -&gt; unit<br />&#160;&#160;&#160;&#160;member CopyTo : System.IO.Stream * int -&gt; unit<br />&#160;&#160;&#160;&#160;member Dispose : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member EndRead : System.IAsyncResult -&gt; int<br />&#160;&#160;&#160;&#160;member EndWrite : System.IAsyncResult -&gt; unit<br />&#160;&#160;&#160;&#160;member Flush : unit -&gt; unit<br />&#160;&#160;&#160;&#160;member Length : int64<br />&#160;&#160;&#160;&#160;member Position : int64 with get, set<br />&#160;&#160;&#160;&#160;member Read : System.Byte [] * int * int -&gt; int<br />&#160;&#160;&#160;&#160;member ReadByte : unit -&gt; int<br />&#160;&#160;&#160;&#160;member ReadTimeout : int with get, set<br />&#160;&#160;&#160;&#160;member Seek : int64 * System.IO.SeekOrigin -&gt; int64<br />&#160;&#160;&#160;&#160;member SetLength : int64 -&gt; unit<br />&#160;&#160;&#160;&#160;member Write : System.Byte [] * int * int -&gt; unit<br />&#160;&#160;&#160;&#160;member WriteByte : System.Byte -&gt; unit<br />&#160;&#160;&#160;&#160;member WriteTimeout : int with get, set<br />&#160;&#160;&#160;&#160;static val Null : System.IO.Stream<br />&#160;&#160;&#160;&#160;static member Synchronized : System.IO.Stream -&gt; System.IO.Stream<br />&#160;&#160;end<br /><br />Full name: System.IO.Stream<br /><br />&#160;&#160;type: System.IO.Stream<br />&#160;&#160;implements: System.IDisposable<br />&#160;&#160;inherits: System.MarshalByRefObject<br /></div>
<div class="tip" id="fasyst227">member System.IO.Stream.AsyncReadSeq : ?bufferSize:int -&gt; AsyncSeq&lt;byte []&gt;<br /><br />Full name: FSharp.Control.IOExtensions.AsyncReadSeq<br /></div>
<div class="tip" id="fasyst228">Multiple items
<br />val int : &#39;T -&gt; int (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.int
<br /><br />--------------------<br />
<br />type int&lt;&#39;Measure&gt; = int<br /><br />Full name: Microsoft.FSharp.Core.int&lt;_&gt;<br /><br />&#160;&#160;type: int&lt;&#39;Measure&gt;<br />&#160;&#160;implements: System.IComparable<br />&#160;&#160;implements: System.IConvertible<br />&#160;&#160;implements: System.IFormattable<br />&#160;&#160;implements: System.IComparable&lt;int&lt;&#39;Measure&gt;&gt;<br />&#160;&#160;implements: System.IEquatable&lt;int&lt;&#39;Measure&gt;&gt;<br />&#160;&#160;inherits: System.ValueType<br />
<br /><br />--------------------<br />
<br />type int = int32<br /><br />Full name: Microsoft.FSharp.Core.int<br /><br />&#160;&#160;type: int<br />&#160;&#160;implements: System.IComparable<br />&#160;&#160;implements: System.IFormattable<br />&#160;&#160;implements: System.IConvertible<br />&#160;&#160;implements: System.IComparable&lt;int&gt;<br />&#160;&#160;implements: System.IEquatable&lt;int&gt;<br />&#160;&#160;inherits: System.ValueType<br /></div>
<div class="tip" id="fasyst229">Multiple items
<br />module AsyncSeq<br /><br />from FSharp.Control
<br /><br />--------------------<br />
<br />type AsyncSeq&lt;&#39;T&gt; = Async&lt;AsyncSeqInner&lt;&#39;T&gt;&gt;<br /><br />Full name: FSharp.Control.AsyncSeq&lt;_&gt;<br /></div>
<div class="tip" id="fasyst230">Multiple items
<br />val byte : &#39;T -&gt; byte (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.byte
<br /><br />--------------------<br />
<br />type byte = System.Byte<br /><br />Full name: Microsoft.FSharp.Core.byte<br /><br />&#160;&#160;type: byte<br />&#160;&#160;implements: System.IComparable<br />&#160;&#160;implements: System.IFormattable<br />&#160;&#160;implements: System.IConvertible<br />&#160;&#160;implements: System.IComparable&lt;byte&gt;<br />&#160;&#160;implements: System.IEquatable&lt;byte&gt;<br />&#160;&#160;inherits: System.ValueType<br /></div>
<div class="tip" id="fasyst231">member System.IO.Stream.AsyncWriteSeq : AsyncSeq&lt;byte []&gt; -&gt; Async&lt;unit&gt;<br /><br />Full name: FSharp.Control.IOExtensions.AsyncWriteSeq<br /></div>

</div></div></div></div></div></div>
</body></html>